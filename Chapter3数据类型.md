P35——P62

[toc]

# 变量大小和范围

变量在同一个作用域中不可以重名。

无论在什么 OS 中，各类型所占的空间大小size一定，保证代码的可移植性。

八种基本数据类型

数字类型（整数类型，浮点类型）字符类型 逻辑布尔类型

| 类型         | 大小 size (单位：bit) | 默认值 | 数据范围                                   |
| ------------ | --------------------- | ------ | ------------------------------------------ |
| byte字节     | 8                     | 0      | -128 - 127                                 |
| short短整型  | 16                    | 0      | -32768 - 32767                             |
| int整形      | 32                    | 0      | -2147483648 - 2147483647                   |
| long长整型   | 64                    | 0      | -9223372036854775808 - 9223372036854775807 |
| float单精度  | 32                    | 0.0    | 1.4E-45 —— 3.4028235E38                    |
| double双精度 | 64                    | 0.0    | 4.9E-324 —— 1.7976931348623157E308         |
| char字符     | 16                    |        |                                            |
| boolean布尔  | 8                     | false  | -128 - 127                                 |

> 浮点数在机器中存放的形式
>
> 浮点数 = 符号位 + 指数位 + 尾数位
>
> 注意📢 尾数部分可能丢失，造成精度损失（浮点数 都是近似值不是真实值。）
>
> ```java
> jshell> double a = 0.5-0.4
> a ==> 0.09999999999999998
> 
> jshell> a = 8.1/3
> a ==> 2.6999999999999997
> 
> //因此当对运算结果是小数的进行相等性判断时要小心处理。
> ////应该是以两个数的差值的绝对值，在某个精度范围类判断。
> ```

float 类型的赋值需要在 常量值（字面量） 的后面 添加  F/f 后缀。直接写小数会被认为是 double类型 赋值给 float 类型。e.g. `float f = 3.14F`

`double d = 3.14d; double d = 3.14D;`  也可以，但是没必要

同样，long 类型的赋值需要在常量值（字面量）的后面写上后缀 L/l。<u>***因为整数字面常量默认是 int 类型的。（但是 byte 和 short 可以赋值自己范围内的整数字面量，也不需要加后缀什么的）***</u>

**<u>*Java 允许大范围的变量被赋值小范围的值。*</u>**反过来不可以，e.g.

`int a = 123L;`和 `float f = 1.23;` 会报错！(1.23字面量默认是 double 类型的)

`long l = (int) 123;` 和 `double d = 1.23F;` 可以通过编译。

类似于 `0.xxx` 的浮点数赋值时可以省略 `0`。e.g.

`double d = .456`  可以通过编译。

浮点数赋值也可以写科学计数法形式。

521.1314 等价于 5.211314E2 或者 5.211314e2

0.0521 等价于 5.21E-2 或者 5.21e-2

double 类型推荐被使用(在不确定应该使用精度为多少的情况下)。

浮点数即使计算出整数也会带有`.0`。

但是 BIgDecimal类 不会产生误差。

# +号的使用

运算顺序从左到右。

a + b

只要 a 和 b 有一个是字符串，就会做拼接操作，产生一个新的字符串。

a + b + c

只有 c 是字符串，a 和 b 都是数字。会先计算 a 和 b 的和，然后再和 c 进行拼接操作。

# Java 数据类型

- 基本数据类型：数值型（byte、short、int、long、float、double）、字符型（char）、布尔型（boolean）
- 引用数据类型：类class、接口interface、数组 [ ]

# Java API 文档

Java类的组织形式：

Java 由许多模块如 java.base，每个模块下还可以有不同的包如 java.io、java.lang、java.math等等，然后每个包下有类、接口或者异常、枚举等等。

以上是 Java API 的文件组织模式，也就是在导包时的路径。

实际上类的继承关系和文件的物理存放是没有太大关系的。

比如所有的类都继承了Object 类，但是不是所有的类都放在 java.lang （object 类所在地文件夹）文件夹下。

# 字符类型char

必须用 `''`单引号括起来才是字符类型。

本质是整数，可以进行自增自减运算。

转义字符尽管看起来是两个字符，但是代表一个字符。

char 是两个字节，可以存放汉字。

多个字符我们用 String 存放。

字符编码转换网站：Https://tool.chinaz.com/Tools/Unicode.aspx

打印字符所代表的数字，可以用强转： `sout((int)'a')`

Java 代码的编写其实可以全部用 Unicode 来表示 格式为 \uxxxx (其中 xxxx 表示四位二进制数)。e.g.

```java
\\   \u0028表示(   \u0029表示)
\\   所以下面的等价于 System.out.println((int)'謁') 
\\ （这里的謁是不对的，typora 显示不出来那个特殊字符）  
jshell> System.out.println\u0028(int)'\uFABC'\u0029
64188
// 十六进制的 FABC 正是 十进制的 64188
jshell> System.out.println\u0028'\uFABC'\u0029
```

char类型是可以进行运算的，相当于一个整数，因为它都对应有Unicode码。

`sout('a' + 10);`

`输出 107`

`char c 和 char c1 相加得到的是整数，而不是字符拼接！`

- ASCII  (ASCII 编码表 1个字节表示，一共 128 个 字符，实际上一个字节可以表示256个字符,只用128个)
- Unicode (Unicode 编码表——<u>更准确来说是一个字符集！</u> 固定大小的编码 使用两个字节来表示字符，字母和汉字统一都是占用两个字节，这样浪费空间) <u>***兼容 ASCII***</u>
- utf-8(编码表，大小可变的编码 字母使用1个字节，汉字使用3个字节
- gbk(可以表示汉字，而且范围广，字母使用1个字节，汉字2个字节)
- gb2312(可以表示汉字，gb2312<gbk)
- big5 码(繁体中文,台湾，香港)

> 打印所有的 Unicode 的方法

Unicode 中的字符数量远远超过 Java 中的 **`char`** 类型能够表示的范围。**`char`** 类型虽然占用两个字节（16比特），但Unicode字符集的码点范围是从U+0000到U+10FFFF，这意味着有超过一百万个可能的码点。

在 Java 中，你可以使用 **`int`** 类型来表示 Unicode 码点，因为 **`int`** 类型是32位的，足够容纳 Unicode 字符集的所有码点。例如：

```java
javaCopy code
int unicodeCodePoint = 0x1F603; // Unicode 码点 U+1F603 对应笑脸 😃
System.out.println(Character.toChars(unicodeCodePoint)); // 输出: 😃
```

在这个例子中，**`unicodeCodePoint`** 是 Unicode 码点 U+1F603，通过 **`Character.toChars`** 方法将其转换为字符数组，然后输出。

使用 **`int`** 类型可以更灵活地处理 Unicode 字符集中的所有字符。当然，Java的 **`char`** 类型仍然适用于表示常用字符范围内的字符，但对于 Unicode 字符集的全范围，建议使用 **`int`** 类型。

> ### 取出字符串的中第 n 个字符
>
> String s = "abc";
>
> char c = s.charAt(1);
>
> sout(c);
>
> 打印得到 b

# 布尔变量

不可以0或非0的整数替代false和true，这点和G语言不同。

# 基本数据类型自动转换

当java程序在进行赋值或者运算时，精度小的类型自动转换为精度大的数据类型，这个就是自动类型转换。

> 数据类型按精度（容量）大小排序为
>
> char → int → long → float → double
>
> byte →short → int → long → float → double
>
> <u>***可以看出 （byte、short） 这俩 和 char 完全不会发生自动转换！***</u>它们的自动转换会报错！！！

- 自动类型转换的注意事项和细节

  - 有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算。
    `float di = int1 + 1.1;`会报错的！

  - 当我们吧精度（容量）大的数据类型赋值给精度小（容量小）的数据类型时会报错，反之就会自动类型转换。

  - byte，short，char他们三者可以计算，在计算时首先转换为int类型，因此 

    ```java
    byte b1 = 1;
    byte b2 = 2
    short s1 =12;
    short s2 = s1 + b1;  //报错！！
    //因为 s1 + b1 计算后得到的 int 类型的字面量！
    byte b3 = b1 + b2; //仍然报错！b1+b2->int
    ```

  - boolean 不参与转换

  - 自动提升原则: 表达式结果的类型自动提升为 操作数中最大的类型

```java
//(byte，short)和char之间不会相互自动转换
//当把具体数赋给 byte 和 short 时,(1)先判断该数是否在byte 和 short 范围内，如果是就可以
byte b1 = 10;//对，-128-127
int n2 = 1;//n2 是int
byte b2 = n2; //报错！

整数类型的赋值：
  变量赋值 给 变量，先判断数据类型，大转小就会报错
	字面量 赋给 变量，先判断表达范围，符合范围就可以
  但是 long 又是一个例外，
  long l = 25000000000; //25亿 会报错，因为 25 亿超出了整形 int 的范围。字面量默认是整形 int 类型。
  必须这样：
  long l = 25000000000L;
```

> java的 short、byte 为什么不能和 char 发生 自动转换？
>
> ChatGPT
>
> 在Java中，有一些数据类型之间的自动类型转换是允许的，这被称为隐式类型转换或自动类型转换。然而，并非所有类型之间都可以进行自动转换，因为可能会导致数据丢失或不确定性。
>
> `short`、`byte` 和 `char` 是Java中的不同的基本数据类型，它们之间的自动类型转换是受到限制的。具体而言，`short`、`byte` 和 `char` 之间不能发生隐式类型转换的原因在于它们之间的表示范围和符号性质的不同。
>
> -  **byte**：是8位的有符号整数，表示范围为 -128 到 127。
> - **short**：是16位的有符号整数，表示范围为 -32,768 到 32,767。
> - **char**：是16位的无符号Unicode字符，表示范围为 0 到 65535。
>
> 由于这些类型的表示范围和符号性质不同，将它们之间进行自动转换可能导致信息的丢失或不一致。例如，将一个包含负值的 `byte` 或 `short` 直接转换为 `char` 可能导致符号位丢失，而将 `char` 直接转换为 `byte` 或 `short` 可能导致范围溢出。
>
> 要进行这些类型之间的转换，你需要显式地进行类型转换，即使用强制类型转换。例如：
>
> ```java
> byte b = 100;
> char c = (char) b; // 强制类型转换
> 
> short s = 200;
> char c2 = (char) s; // 强制类型转换
> ```
>
> 在进行强制类型转换时，你需要注意可能引起的数据截断或溢出问题。

# 基本数据类型强制转换

自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符`(Type)`，但可能造成精度降低或溢出,格外要注意。

> 强制类型转换的细节说明
>
> - 当进行数据的大小从 大-->小，就需要使用到强制转换
> - 强转符号只针对于最近的操作数有效，往往会使用小括号提升优先级
> - char类型可以保存int的常量值，但不能保存int的变量值，需要强转
> - byte和short类型在进行运算时，当做 int 类型处理。

# Boolean 类型的强制转换和自动转换

在Java中，boolean类型与其他基本数据类型之间不能发生自动转换或强制转换。boolean类型只能取两个值：true和false。它不与其他基本数据类型进行数值上的转换。

如果你有一个boolean类型的值，想要将其转换为其他类型，你需要显式地进行类型转换。例如，如果有一个boolean变量`isTrue`，你想将其转换为整数（int），可以这样做：

```java
boolean isTrue = true;
int intValue = isTrue ? 1 : 0;
```

这里使用了条件运算符（三元运算符）来将boolean值转换为整数。如果`isTrue`为true，`intValue`将被赋值为1；如果为false，`intValue`将被赋值为0。

需要注意的是，虽然在Java中boolean类型不能直接转换为其他基本数据类型，但是在一些上下文中，boolean值会被自动转换为与其相容的类型。例如，boolean值可以直接用于条件语句中，而不需要显式地进行转换。

# 基本数据类型和 String 类型的转换 parseType()方法

- 基本类型转String类型语法:
  - 将基本类型的值+""（一个空串）即可

- String类型 转 基本数据类型语法：
  - 通过基本类型的包装类调用parseXX方法即可

​	`Integer.parseInt("123");`//这里不可以是小数 e.g.  12.3

​	`Double.parseDouble("123.1");`

​	`Float.parseFloat("123.45");`

​	`Short.parseshort("12");`

​	`Long.parseLong("12345");`

​	`Boolean.parseBoolean("true")`

​	`Byte.parseByte("12");`

​	char类型也有自己的包装类 —— Character

怎么把字符串转成字符char ->含义是指 把字符串的第n个字符得到。

```java
String s = "love";
System.out.println(s.charAt(0));
//会打印出 l
System.out.println(s.charAt(2));
//会打印 v
```

1. 在将String 类型转成 基本数据类型时，要确保String类型能够转成有效的数据，比如 我们可以把"123”，转成一个整数，但是不能把"hello"转成一个整数。”123.456“也不能通过 Integer.parseInt(123.456) 转换成 int 类型！
2. 如果格式不证确，就会抛出异常，程序就会终止，这个问题在异常处理章节中，会处理。格式不正确的转换，可以通过编译，但是运行时会报错。