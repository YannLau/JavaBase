P374——P424

[toc]

# 类变量和类方法 static

> 什么是类变量？
>
> 类变量也叫静态变量/静态属性，是该类的所有对象共享的变量，任何一个该类的对象去访问它时，取到的都是相同的值，同样任何一个该类的对象去修改它时，修改的也是同一个变量。这个从前面的图也可看出来。

> 定义语法：
>
> 访问修饰符 static 数据类型 变量名；［推荐］
> static 访问修饰符 数据类型 变量名；

> 类变量在内存的哪里？
>
> JDK8 以前静态变量（类变量）存在于方法区加载类时产生的静态域中。JDK8 以后加载类时，会在堆区生成一个 Class对象（Class实例），类变量就存放在Class 实例的尾部。
>
> 不管static 变量在哪里，共识（1） static 变量是同一个类所有对象共享（2） static类变量，在类加载的时候就生成了.

> 如何访问类变量？
>
> 类名.类变量名
> 或者 对象名.类变量名【静态变量的访问修饰符的访问权限和范围 和 普通属性是一样的。】
> 推荐使用：类名.类变量名；

> 类变量使用细节
>
> 1. 什么时候需要用类变量
>     当我们需要让某个类的所有对象都共享一个变量时，就可以考虑使用类变量（静态变量）：比如：定义学生类，统计所有学生共交多少钱。Student （name, fee）
> 2. 类变量与实例变量（普通属性）区别
>     类变量是该类的所有对象共享的，而实例变量是每个对象独享的。
> 3. 加上static称为类变量或静态变量，否则称为实例变量/普通变量/非静态变量
> 4. 类变量可以通过 类名.类变量名 或者 对象名.类变量名 来访问，但java设计者推荐我们使用 类名.类变量名方式访问。【前提是 满足访问修饰符的访问权限和范围】
> 5. 实例变量不能通过 类名.类变量名 方式访问。
> 6. 类变量是在类加载时就初始化了，也就是说，即使你没有创建对象，只要类加载了，就可以使用类变量了。
> 7. 类变量的生命周期是随类的加载开始，随着类消亡而销毁。

> 类方法
>
> 也叫静态方法。
>
> 书写方法：
>
> 访问修饰符 static 数据返回类型 方法名()｛｝【推荐】
> static 访问修饰符 数据返回类型 方法名()｛｝
>
> 类方法调用：
>
> 使用方式：类名.类方法名 或者 对象名.类方法名【前提是 满足访问修饰符的访问权限和范围】

> 类方法经典的使用场景
> >当方法中不涉及到任何和对象相关的成员，则可以将方法设计成静态方法，提高开发效率。
> >比如：工具类中的方法 Util 类、Math 类、Arrays类、Collections 集合类
> >
> >> 小结
> >>
> >> 在程序员实际开发，往往会将一些通用的方法，设计成静态方法，这样我们不需要创建对象就可以使用了，比如打印一维数组，冒泡排序，完成某个计算任务 等

> 类方法使用细节
>
> 1）类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区：类方法中无this的参数，普通方法中隐含着this的参数。
> 2） 类方法可以通过类名调用，也可以通过对象名调用。
> 3） 普通方法和对象有关，需要通过对象名调用，比如对象名.方法名（参数），不能通过类名调用。
> 4） 类方法中不允许使用和对象有关的关键字，比如this和super。普通方法（成员方法）可以。
> 5） 类方法（静态方法）中 只能访问 静态变量 或静态方法。
> 6） 普通成员方法，既可以访问 普通变量（方法），也可以访问静态变量（方法）。
>
> 小结：静态方法，只能访问静态的成员，非静态的方法，可以访问静态成员和非静态成员（必须遵守访问权限）。

> yannlau补充:
>
> java 类的静态方法可以被重写吗？
>
> ChatGPT
>
> 在Java中，静态方法是属于类的而不是对象的，因此它们不支持被重写。静态方法是与类关联而不是与对象关联的，因此子类不能重写父类的静态方法。如果在子类中声明一个与父类静态方法签名相同的静态方法，它只是隐藏了父类的静态方法，而不是重写它。
>
> 当在子类中声明一个与父类静态方法相同的静态方法时，会发生"方法隐藏"而不是"方法重写"。在这种情况下，方法调用将取决于引用类型，而不是实际对象类型。如果通过父类引用调用该方法，将调用父类的静态方法；如果通过子类引用调用该方法，将调用子类的静态方法。
>
> 总的来说，<u>***静态方法不会遵循动态分派的规则，因此无法被重写。***</u>

> 那么 java 的静态类不支持动态绑定机制吗？父类中调用一个静态方法不会现在子类中查找吗？
>
> ChatGPT
>
> 在Java中，静态方法和静态成员是与类相关联而不是与对象相关联的，因此它们不参与动态绑定（也称为运行时多态性）。动态绑定是通过对象的类型来解析方法调用的，而不是通过引用的类型。由于静态成员和方法与类相关，而不是与对象相关，所以它们不受动态绑定的影响。
>
> 当通过一个类的引用调用静态方法时，会直接使用该类中定义的静态方法，而不会根据实际对象的类型进行查找。因此，即使通过父类的引用调用静态方法，也会调用父类中定义的静态方法，而不是在子类中查找。
>
> 示例：
>
> ```java
> class Parent {
>     static void staticMethod() {
>         System.out.println("Parent's static method");
>     }
> }
> 
> class Child extends Parent {
>     static void staticMethod() {
>         System.out.println("Child's static method");
>     }
> }
> 
> public class Main {
>     public static void main(String[] args) {
>         Parent.staticMethod(); // 调用父类的静态方法
>         Child.staticMethod();  // 调用子类的静态方法
> 
>         Parent parentReference = new Child();
>         parentReference.staticMethod();  // 仍然调用父类的静态方法
>     }
> }
> ```
>
> 在上述示例中，无论是通过父类引用还是子类引用调用静态方法，实际上都是直接使用引用类型所属类中定义的静态方法，而不会动态查找。



# 深入理解 main 方法

> 解释main方法的形式：`public static void main（String［］ args){}`
>
> 1. java虚拟机需要调用类的main方法，所以该方法的访问权限必须是public）
>
> 2. java虚拟机在执行main()方法时不必创建对象，所以该方法必须是static
> 3. 该方法接收String类型的数组参数，该数组中保存执行java命令时传递给所运行的类的参数，案例演示，接收参数.
> 4. java 执行的程序 参数1 参数2 参数3

> 理解 main 方法语法
>
> 1） 在main方法中，我们可以真接调用main方法所在类的静态方法或静态属性。
> 2） 但是，不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员。

> 在 IDEA 中动态传参
>
> Run/Bug Configuration ——> Program arguments

# 代码块/初始化块

代码化块又称为初始化块，属于类中的成员［即 是类的一部分］，类似于方法，将逻辑语句封装在方法体中，通过f包围起来。

但和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或类显式调用，而是加载类时，或创建对象时隐式调用。

> 基本语法
>
> `［修饰符］｛`
> 	`代码`
> `｝;`
>
> 注意：
> 1） 修饰符 可选，要写的话，也只能写 static
> 2）代码块分为两类，使用static 修饰的叫静态代码块，没有static修饰的，叫普通代码块。
> 3）逻辑语句可以为任何逻辑语句（输入、输出、方法调用、循环、判断等）
> 4）; 分号可以写上，也可以省略。

> 代码块的好处和理解：
> 1）相当于另外一种形式的构造器（对构造器的补充机制），可以做初始化的操作
> 2） 如果多个构造器中都有重复的语句，可以抽取到初始化块中，提高代码的重用性

> 使用场景
>
> （1） 三个构造器都有相同的语句
> （2） 这样代码看起来比较冗余
> （3）这时我们可以把相同的语句，放入到一个代码块中
> （4）这样当我们不管调用哪个构造器，创建对象，都会先谓用代码块的内容
> （5）代码块调用的顺序优先于构造器。

> 代码块使用注意事项和细节
>
> 1. static代码块也叫静态代码块，作用就是对类进行初始化，而且它随着类的加载而执行，并且只会执行一次。如果是普通代码块，每创建一个对象，就执行。
> 2. 类什么时候被加载【重要】
>    1. 创建对象实例时（new）
>    2.  创建子类对象实例，父类也会被加载 (而且要先加载父类) 注意类加载和对象实例化是不一样的。~~经过代码验证发现，一个类的加载过程是，先加载字类的成员（包括静态成员和非静态成员并进行初始化），然后执行静态代码块~~，因为静态代码块可以访问到静态成员！
>    3.  使用类的静态成员时（静态属性，静态方法）
>       案例演示：A类 extends B类 的静态块
> 3. 普通的代码块，在创建对象实例时，会被隐式的调用。
>    被创建一次，就会调用一次。如果只是使用类的静态成员时，普通代码块并不会执行。
> 4. 创建一个对象时，在一个类 调用顺序是：（重点，难点）：
>    1.  调用静态代码块和静态属性初始化（注意：静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态变量初始化，则按他们定义的顺序调用）
>    2.  调用普通代码块和普通属性的初始化（注意：普通代码块和普通属性初始化调用的优先级一样，如果有多个普通代码块和多个普通属性初始化，则按定义顺序调用）
>    3. 调用构造方法。
>    4. 类的方法（静态方法）加载的更早，比静态代码块和静态属性更早。
> 5. 构造方法（构造器）的最前面其实隐含了 super() 和 调用普通代码块，静态相关的代码块，属性初始化，在类加载时，就执行完毕，因此是优先于 构造器和普通代码块执行的
> 6. 我们看一下创建一个子类对象时（继承关系），他们的静态代码块，静态属性初始化，普通代码块，普通属性初始化，构造方法的调用顺序如下：
>    1.  父类的静态代码块和静态属性（优先级一样，按定义顺序执行）
>    2.  子类的静态代码块和静态属性（优先级一样，按定义顺序执行）
>    3. 父类的普通代码块和普通属性初始化（优先级一样，按定义顺序执行）
>    4. 父类的构造方法
>    5. 子类的普通代码块和普通属性初始化（优先级一样，按定义顺序执行）
>    6. 子类的构造方法
> 7. 静态代码块只能直接调用静态成员（静态属性和静态方法），普通代码块可以调用任意成员。
> 8. YannLau补充：类的静态部分只有在第一次类被加载时才会执行或初始化。第二次创建相关对象时就不用在加载了！包括继承关系的子类第一次加载时也不会再加载了。因为已经加载过了。

# 单例设计模式

> 什么是设计模式？
>
> 1. 静态方法和属性的经典使用
> 2. 设计模式是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式。设计模式就像是经典的棋谱，不同的棋局，我们用不同的棋谱，免去我们自己再思考和摸索。

> 什么是单例模式？
>
> 单例（单个的实例）
> 1. 所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法
> 2. 单例模式有两种方式：1）饿汉式 2）懒汉式

> 饿汉式（可能还没有用到，对象就已经创建好了）
>
> 1） 构造器私有化
> 2） 类的内部创建对象（该对象是 static 的）直接 new 出来一个对象。
> 3） 向外暴露一个静态的公共方法 getlnstance，返回 对象。
> 4） 代码实现

> 懒汉式
>
> 引用变量 默认值是 null ，因此创建对象的引用，不直接 new 而是在 getInstance 中 new，并添加判断，使得确保唯一性。
>
> 1. 仍然構造器私有化
> 2. 定義一個static靜態屬性對象 不赋值或者置为 null
> 3. 提供一個public的static方法，可以返回一個Cat對象
> 4. 懶漢式，只有當用戶使用getInstance時，才返回cat對象，後面再次調用時，會返回上次創建的cat對象從而保證了單例

> 饿汉式和懒汉式比较
>
> 饿汉式VS懒汉式
>
> 1. 二者最主要的区别在于创建对象的时机不同：饿汉式是在类加载就创建了对象实例，而懒汉式是在使用时才创建。
> 2. 饿汉式不存在线程安全问题，懒汉式存在线程安全问题。（后面学习线程后，会完善一把）
> 3. 饿汉式存在浪费资源的可能。因为如果程序员一个对象实例都没有使用，那么饿汉式创建的对象就浪费了，懒汉式是使用时才创建，就不存在这个问题。
> 4. 在我们javaSE标准类中，java.lang.Runtime就是经典的单例模式。

# final 关键字

> final 中文意思：最后的，最终的.
> final 可以修饰类、属性、方法和局部变量。
>
> 在某些情况下，程序员可能有以下需求，就会使用到final
>
> 1）当不希望类被继承时，可以用final修饰.
>
> 2）当不希望父类的某个方法被子类覆盖/重写（override）时，可以用final关键字修饰。【案例演示：访问修饰符 final 返回类型 方法名】
>
> 3）当不希望类的的某个属性的值被修改，可以用final修饰.【案例演示：public final double TAX_RATE=0.08]
>
> 4）当不希望某个局部变量被修改，可以使用final修饰【案例演示：final double TAX RATE =0.08 ]

> final  关键子使用细节
>
> 1. final修饰的属性又叫常量，一般 用 XX_XX_XX_XX 来命名
> 2. final修饰的属性在定义时，必须赋初值，并且以后不能再修改，赋值可以在如下位置之一【选择一个位置赋初值即可】：
>    1. 定义时：如 public final double TAX RATE=0.08；
>    2. 在构造器中。
>    3. 在代码块中。
> 3. 如果final修饰的属性是静态的，则初始化的位置只能是
>    1. 定义时
>    2. 在静态代码块，不能在构造器中赋值。final类不能继承，但是可以实例化对象。
> 4. final类不能继承，但是可以实例化对象。
> 5. 如果类不是final类，但是含有final方法，则该方法虽然不能重写，但是可以被继承。
> 6. 一般来说，如果一个类已经是final类了，就没有必要再将方法修饰成final方法。
> 7. final不能修饰构造方法（即构造器）
> 8. final 和 static 往往搭配使用，效率更高，底层编译器做了优化处理。
> 9. 包装类（Integer, Double,Float, Boolean等都是final），String也是final类。

# 抽象类abstract

父类方法的不确定性 ==> 考虑将该方法设计为抽象(abstract)方法。

所谓抽象的方法就是指没有实现没有方法体的方法！

当一个类中存在抽象方法时，需要将类声明为抽象类！

给类定义增加 abstract 关键字，并让子类实现该方法（且必须要实现，除非子类也设为 abstract）。

> 语法: 
>
> ```java
> package com.hspedu.abstract_;
> public class Abstract01 {
>   public static void main(String[] args) {
>   }
> }
> abstract class Animal {
>   private String name;
>   public Animal(String name) {
>     this.name = name;
>   }
>   //思考：这里 eat 这里你实现了，其实没有什么意义
>   //即： 父类方法不确定性的问题
>   //===> 考虑将该方法设计为抽象(abstract)方法
>   //===> 所谓抽象方法就是没有实现的方法
>   //===> 所谓没有实现就是指，没有方法体
>   //===> 当一个类中存在抽象方法时，需要将该类声明为 abstract 类
>   //===> 一般来说，抽象类会被继承，有其子类来实现抽象方法. // public void eat() {
>   // System.out.println("这是一个动物，但是不知道吃什么..");
>   // }
>   public abstract void eat() ;
> }
> ```

小结：

当父类的某些方法，需要声明，但是又不确定如何实现时，可以将其声明为抽象方法，那么这个类就是抽象类。

> 介绍
>
> 1） 用abstract 关键字来修饰一个类时，这个类就叫抽象类`访问修饰符 abstract类名｛ ｝`
> 2） 用abstract关键字来修饰一个方法时，这个方法就是抽象方法 —— 访问修饰符 abstract 返回类型 方法名（参数列表）：//没有方法体
> 3） 抽象类的价值更多作用是在于设计，是设计者设计好后，让子类继承并实现抽象类()
> 4） ==抽象类，是考官比较爱问的知识点，在框架和设计模式使用较多==。

> 抽象类细节
>
> 1. 抽象类不能被实例化
>
> 2. 抽象类不一定要包含abstract方法。也就是说，抽象类可以没有abstract方法
>
> 3. 一旦类包含了abstract方法，则这个类必须声明为abstract 
>
> 4. abstract 只能修饰类和方法，不能修饰属性和其它的 
>
> 5. 抽象类可以有任意成员【抽象类还是类】，比如：非抽象方法(实例方法)、构造器、静态属性等等
>
> 6. 抽象方法不能有主体，即不能当场直接实现implement
>
>    ![QQ_1726144165805](/Users/yannlau/Documents/JavaSet/Java韩顺平/第1阶段_Java900P_韩顺平 + 个人理解积累补充/assets/QQ_1726144165805.png)
>
> 7. 如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为abstract类。那如果抽象父类只是声明为抽象类但不包含任何抽象方法的话，也就不用实现了。
>
> 8. `抽象方法不能使用private、final 和 static来修饰`，因为这些关键字都是和重写相违背的。

> 为什么抽象方法不能用 private 关键字修饰？
>
> ChatGPT
>
> 在Java中，抽象方法是声明在抽象类或接口中的方法，而抽象方法的目的是为了让派生类（子类）提供具体的实现。抽象方法是一种约定，它告诉子类必须提供对应的实现。
>
> 使用`private`关键字修饰抽象方法是不合法的，原因如下：
>
> 1. **访问权限问题：** `private`修饰的成员只能在声明它的类内部访问，对外不可见。而抽象方法的目的是为了被子类实现，如果将抽象方法声明为`private`，那么子类将无法访问该方法，从而无法提供实现。
> 2. **继承和多态性：** 抽象方法是为了促使子类提供具体实现，而`private`方法不能被继承，因此无法达到这个目的。子类无法继承私有方法，因此无法提供相应的实现。
>
> 如果将抽象方法声明为`private`，就违背了其设计目的，因为它无法被子类继承和实现，从而失去了多态性和继承的优势。因此，Java中规定抽象方法不能使用`private`修饰符。

> 有 静态抽象方法 一说吗？
>
> 在Java中，`抽象方法 是一种声明在 抽象类 或 接口 中的方法`，而静态方法是与类相关联而不是与对象相关联的。在Java 8及之前的版本中，抽象方法不能是静态的。然而，从Java 8开始，接口中可以包含静态方法。
>
> 具体来说，Java 8引入了接口的默认方法和静态方法。接口中的静态方法可以提供一些通用的功能，而不需要实现类去实现这些方法。这使得在接口中引入新方法时更加灵活，而不会破坏已有的实现类。
>
> 示例：
>
> ```java
> interface MyInterface {
>  void abstractMethod(); // 抽象方法
> 
>  static void staticMethod() {
>      System.out.println("Static method in interface");
>  }
> }
> 
> class MyClass implements MyInterface {
>  @Override
>  public void abstractMethod() {
>      System.out.println("Implementation of abstract method");
>  }
> }
> 
> public class Main {
>  public static void main(String[] args) {
>      MyInterface.staticMethod(); // 调用接口中的静态方法
> 
>      MyClass myClass = new MyClass();
>      myClass.abstractMethod();    // 调用实现类中的抽象方法
>  }
> }
> ```
>
> 在上述示例中，`MyInterface`接口包含一个抽象方法`abstractMethod`和一个静态方法`staticMethod`。实现类`MyClass`需要提供对抽象方法的具体实现，但不需要实现静态方法。静态方法可以直接通过接口名调用，而不需要创建接口的实例。
>
> java静态方法可以进行重写吗？
>
> ChatGPT
>
> Java 中 **静态方法不能被重写**，只能被**隐藏**。这是因为静态方法属于类本身，而不是某个具体对象的实例。重写（Override）是针对实例方法的，它依赖于运行时的动态绑定（即多态），而静态方法在编译时就已经绑定到类上了，因此不能参与运行时的动态分派。
>
> ### 静态方法的隐藏（Hiding）
>
> 虽然静态方法不能被重写，但可以在子类中声明一个与父类相同签名的静态方法，这样父类的静态方法在子类中就会被**隐藏**。这种情况下，调用的是声明该方法的类的版本，而不是父类的版本。
>
> ### 示例
>
> ```java
> class Parent {
>     static void staticMethod() {
>       System.out.println("Parent static method");
>     }
> 
>     void instanceMethod() {
>       System.out.println("Parent instance method");
>     }
>   }
> class Child extends Parent {
>   static void staticMethod() {
>     System.out.println("Child static method");
>   }
>   @Override
>   void instanceMethod() {
>     System.out.println("Child instance method");
>   }
> }
> public class Test {
>   public static void main(String[] args) {
>     Parent p = new Child();
> 
>     // 静态方法绑定到类，不依赖实例，表现为"隐藏"
>     p.staticMethod(); // 输出: Parent static method
> 
>     // 实例方法会被重写，依赖于运行时的实际对象
>     p.instanceMethod(); // 输出: Child instance method
>   }
> }
> ```
>
> ### 解释：
>
> - `p.staticMethod()` 调用了父类的静态方法，因为静态方法是**编译时**绑定的，它与对象的实际类型无关，而是根据引用的类型决定，因此调用的是 `Parent` 类的 `staticMethod`。
> - `p.instanceMethod()` 调用了子类的实例方法，这是**运行时**绑定的，依赖于 `p` 引用的实际对象类型（即 `Child`），因此调用了子类的 `instanceMethod`。
>
> ### 总结：
>
> - **静态方法不能被重写，只能被隐藏**。
> - 调用静态方法时，根据引用的**编译时类型**来决定调用哪一个版本，而实例方法则是根据对象的**运行时类型**决定。

# 抽象类的实践——模板设计模式

抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式。

1）`当功能内部一部分实现是确定，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。`

2）编写一个抽象父类，父类提供了多个子类的通用方法，并把一个或多个方法留给其子类实现，就是一种模板模式.

> 需求
>
> 1） 有多个类，完成不同的任务job
> 2） 要求能够得到各自完成任务的时间
> 3） 请编程实现
>
> 1. 先用最容易想到的方法
>
> 2. 分析问题，提出使用模板设计模式

`long end = System.currentTimeMills(); `得到当前的时间戳！

设计一个抽象类（Template），能完成如下功能：
1） 编写方法`calculateTime()`，可以计算某段代码的耗时时间
2） 编写抽象方法job()
3） 编写一个子类Sub，继承抽象类Template，并实现job方法。
4） 编写一个测试类TestTemplate，看看是否好用。

```java
abstract class Template{//抽象类
  
		public abstract void job();//抽象方法
  
		public void caleTimes(){// 统计耗时多久是确定
			//统计当前时间距离 1970-1-1 0:0:0的时间差，单位ms
			long start = System.currentTimeMillis;
			this.job();  //动态绑定机制
			long end = System.currentTimeMillis;
			System.out.printin("耗时: "+(end-start));
		}
}
```

会涉及多态的动态绑定机制！

# 接口 interface

```java
package com.hspedu.interface_;
public interface UsbInterface { //接口
  //规定接口的相关方法,老师规定的.即规范... public void start();
  public void stop();
}

package com.hspedu.interface_;
public class Camera implements UsbInterface{//实现接口,就是把接口方法实现
  @Override
  public void start() {
    System.out.println("相机开始工作...");
  }
  @Override
  public void stop() {
    System.out.println("相机停止工作....");
  }
}

package com.hspedu.interface_;
//Phone 类 实现 UsbInterface
//解读 1. 即 Phone 类需要实现 UsbInterface 接口 规定/声明的方法
public class Phone implements UsbInterface {
  @Override
  public void start() {
    System.out.println("手机开始工作...");
  }
  @Override
  public void stop() {
    System.out.println("手机停止工作.....");
  }
}

package com.hspedu.interface_;
public class Interface01 {
  public static void main(String[] args) {
    //创建手机，相机对象
    //Camera 实现了 UsbInterface
    Camera camera = new Camera();
    //Phone 实现了 UsbInterface
    Phone phone = new Phone();
    //创建计算机
    Computer computer = new Computer();
    computer.work(phone);//把手机接入到计算机
    System.out.println("===============");
    computer.work(camera);//把相机接入到计算机
  }
}
```

### 基本介绍

> 接口就是给出一些没有实现的方法，封装到一起，到某个类要使用的时候，在根据具体情况把这些方法写出来。语法：
>
> `interface 接口名{`
>
> ​	`//属性`
>
> ​	`//方法`
>
> `}`
>
> `class 类名 implements 接口1,接口2,接口3 {`
>
> ​	`//自己属性`
>
> ​	`//自己方法`
>
> ​	`//必须实现的接口抽象方法`
>
> `}`
>
> 小结；接口是更加抽象的抽象的类，抽象类里的方法可以有方法体，接口里的所有方法都没有方法体【jdk7.0】。接口体现了程序设计的多态和高内聚低偶合的设计思想。
>
> 特别说明：Jdk8.0后接口类可以有静态方法，默认方法(实例方法加上default关键字)，也就是说接口中可以有方法的具体实现。但是不可以有专门的实例方法。
>
> 小结：
>
> 1. `在Jdk7.0前 接口里的所有方法都没有方法体。即 都是抽象的方法`（一般不写 abstract 关键字）。`在接口中，抽象方法，可以省略 abstract 关键字。`
> 2. Jdk8.0后接口类可以有静态方法，默认方法（default 修饰——default 放在访问修饰符前面），也就是说接口中可以有方法的具体实现。

> 接口的深入讨论
>
> 对初学者讲.理解接口的概念不算太难，难的是不知道什么时候使用接口，下面我例举几个应用场景：
> 1. 说现在要制造战斗机，武装真升机.专家只需把飞机需要的功能/规格定下来即可，然后让别的人具体实现就可。
>
> 2. 说现在有一个项目经理.管理三个程序员，功能开发一个软件，为了控制和管理软件，项目经理可以定义一些接口，然后由程序员具体实现。
>
>   实际要求：3个程序员，编写三个类，分别完成对Mysql,Oracle,DB2数据库的连接。

> 接口的注意事项和细节
>
> 1）接口不能被实例化
> 2）==接口中所有的方法是 public方法，不写访问修饰符也是默认为 public==，接口中抽象方法，可以省略 abstract 修饰 
>
> `public void aaa();  等价于    public abstract void aaa(); 等价于 void aaa() `  不用加花括号！
>
> 3） 一个普通类实现接口，就必须将该接口的所有方法都实现。
>
> 4） 抽象类实现接口，可以不用实现接口的方法。
>
> 5） 一个类同时可以实现多个接口
>
> 6）接口中的属性，只能是final的，而且是 public static final 修饰符。比如：int a=1；实际上是 `public static final` int a=1;（必须初始化）
>
> 7） 接口中属性的访问形式：`接口名.属性名`
>
> 8） ==一个接口不能继承其它的类，但是可以继承多个别的接口== `interface A extends B,C {}`
>
> 9） 接口的修饰符 只能是 public 和 默认 ，这点和类的修饰符是一样的。
>
> 10） ==Java 中类是单继承的，而接口可以多继承 **这意味着：**类只能继承一个类：在 Java 中，类的继承是单继承，即一个类只能继承另一个类。不能同时继承多个类。

# 接口 VS 继承类

小结：当子类继承了父类，就自动的拥有父类的功能
如果子类需要扩展功能，可以通过实现接口的方式了扩展。

可以理解 实现接口 是 对 java 单继承机制的一种补充。

> 接口和继承解决的问题不同
>
> 1. 继承的价值主要在于：解决代码的复甩性和可维护性。
>
> 2. 接口的价值主要在于：设计，设计好各种规范（方法），让其它类去实现这些方法。
>
> 接口比继承更加灵活
>
> 1. 接口比继承更加灵活，继承是满足 is-a的关系，而接口只需满足like-a的关系。
>
> 接口在一定程度上实现代码解耦【即 接口规范性 + 动态绑定】

# 接口的多态性

1） 多态参数（前面案例体现）InterfacePolyParameter.java
在前面的Usb接口案例，`Usblnterface usb`，既可以接收手机对象，又可以接收相机对象，就体现了 接口 多态（接口引用可以指向实现了接口的类的对象）。

> 接口类型的变量 可以指向 实现了该接口的类的对象

2） 多态数组 InterfacePolyArr.java
演示一个案例：给Usb数组中，存放 Phone 和 相机对象， Phone类还有一个特有的方法call()。请遍历Usb数组，如果是Phone对象，除了调用Usb 接口定义的方法外，还需要调用 Phone 特有方法 call。

3）接口存在多态传递现象.InterfacePolyPass.java

> 1. 接口类型的变量可以指向，实现了该接口的类的对象实例
> 2. 如果A接口继承了另一个B 接口。而类 C 实现了 A 接口，就相当于类 C也实现了 B 接口，那么，B 接口引用变量可以用来指向 类C 的实例对象。这就是接口的多态传递现象！

当一个对象访问 一个父类 和 实现的接口 都有的变量时，用 super.变量名指定父类变量，用 接口名.变量名指代接口变量，避免混淆，否则编译器会报错！

