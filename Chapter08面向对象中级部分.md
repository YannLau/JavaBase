P264——P361

[toc]

# IDEA

> IDEA快捷键的设置

文件→设置→键盘映射：选择eclipse

可以具体给没有快捷键但是常用的操作添加快捷键。如创建类： 设置为ctrl+capslock

选择多个栏目时的快捷键，crtl+shift+方向键

| 序号 |         功能         |                          MacOS 按键                          |   Windows 按键   |                             说明                             |
| :--: | :------------------: | :----------------------------------------------------------: | :--------------: | :----------------------------------------------------------: |
|  1   |      删除当前行      |                     command + backspace                      |      Ctrl+D      | 光标停留在改行任意处，删除后下一行内容自动占据当前位置，光标仍停留在原位或者行尾行首 |
|  2   |      复制当前行      |                         command + D                          |                  |                  直接复制本行到当前行下一行                  |
|  3   |       代码补全       | 基本补全 control+空格    类型匹配补全 control + shift + 空格   补全当前语句command + shift + 回车 |                  |                                                              |
|  4   |    添加/取消注释     |                         command + /                          |                  |                   第一次注释第二次取消注释                   |
|  5   |      格式化代码      |                      option + shift + F                      | ctrl + shift + L |                                                              |
|  6   |         运行         |                       Ctrl + shift + R                       |                  |                                                              |
|  7   |     生成构造方法     |                         Ctrl + 回车                          |                  |                      生成getter setter                       |
|  8   | 查看一个类的层级关系 |                           Ctrl + H                           |                  |                                                              |
|  9   |  显示继承关系弹窗图  |                     command + option + U                     |                  |                        展示简单关系图                        |
|  10  |    显示继承关系图    |                 command + shift + option + U                 |                  |                  打开新标签页展示继承关系图                  |
|  11  |   跳转到方法定义处   |                         command + B                          |                  |                                                              |
|  12  |    快速分配变量名    |                             .var                             |                  |                                                              |
|  13  |   在当前包下新建类   |                     control + shift + N                      |                  |                                                              |
|  14  |       代码环绕       |                       command option T                       |                  |                                                              |
|  15  |    全局修改变量名    |                        shift+(Fn)+F6                         |                  |                                                              |
|  16  | 切换选中内容的大小写 |                     command + shift + U                      |                  |                                                              |
|  17  | 查看类结构Structure  |                         command + 7                          |                  |                                                              |
|  18  |     打开setting      |                         command  + ,                         |                  |                                                              |
|  19  |   control+shift+.    |                           字体放大                           |                  |                                                              |
|  20  |   control+shift+,    |                           字体缩小                           |                  |                                                              |
|      |                      |                                                              |                  |                                                              |
|      |                      |                                                              |                  |                                                              |
|      |                      |                                                              |                  |                                                              |
|      |                      |                                                              |                  |                                                              |
|      |                      |                                                              |                  |                                                              |
|      |                      |                                                              |                  |                                                              |
|      |                      |                                                              |                  |                                                              |
|      |                      |                                                              |                  |                                                              |
|      |                      |                                                              |                  |                                                              |

| 序号 | 功能                                    | 按键                         | 说明                                                         |
| ---- | --------------------------------------- | ---------------------------- | ------------------------------------------------------------ |
| 1    | 运行当前程序                            | ctrl+shift+F10               |                                                              |
| 2    | 单行注释                                | ctrl+/                       | //   取消同理                                                |
| 3    | 多行注释                                | ctrl+shift+/                 | /*   */  取消同理，且不需要全选，光标在注释范围内即可。      |
| 4    | 方法文档注释                            | /**+回车                     | 在方法的前一行进行操作                                       |
| 5    | 新建类、接口等                          | alt+insert                   | 光标移动到包上                                               |
| 6    | 创建类                                  | 自定义为ctrl+shift+N         | 键盘映射→主菜单→文件→新建→java类    添加快捷方式             |
| 7    | 批量修改变量名                          | alt+shift+R                  | 点中变量或光标在变量前后                                     |
| 8    | 万能修复                                | ctrl+1                       | 提示修复问题的方法，也可以用来生成getter和setter方法         |
| 9    | 生成getter 和 setter等方法              | ctrl+1    或      alt+insert | 光标聚焦在编辑器中按alt+insert  可以快捷添加各种方法         |
| 10   | 快生成输出打印语句                      | sout                         |                                                              |
| 11   | 快速生成打印一个变量的值                | soutv                        | System.out.println("io = " + io);  会生成对所属变量的说明"io = " |
| 12   | 快速生成lambda打印                      | soutc                        |                                                              |
| 13   | 快速生成格式化打印                      | souf                         |                                                              |
| 14   | 快速生成变量或对象的打印                | 变量名.sout   变量名.soutv   |                                                              |
| 15   | 快速生成私有常量                        | psfi                         | int类型                                                      |
| 16   |                                         | psfs                         | String类型                                                   |
| 17   |                                         | psf                          | 通用                                                         |
| 18   | 删除当前行                              | ctrl+D                       | 光标停留在当前行即可                                         |
| 18   | 删除光标所在位置后面的一段单词或中文    | ctrl+delete                  | 不能够全部删除，会智能分界                                   |
| 19   | 删除光标后面的所有内容                  | ctrl+shift+delete            | 删除光标后面的所有内容                                       |
| 20   | 代码移动                                | alt+上下方向键               |                                                              |
| 21   | 代码补全                                | 自定义设置为alt+/            | 或者设置关闭输入法的ctrl+空格，启用IDEA默认的ctrl+空格       |
| 22   | 快速生成主函数main                      | psvm或者main                 |                                                              |
| 23   | 查看源码                                | ctrl+鼠标左键 点击类名等     |                                                              |
| 24   | 查看层次结构                            | F4                           |                                                              |
| 25   | 查看类图（弹出式）                      | ctrl+alt+u                   |                                                              |
| 26   | 查看类图（编辑器全屏查看）              | ctrl+shift+alt+u             |                                                              |
| 27   | 查看当前类中的方法                      | ctrl+o   或    alt+7         | ctrl+o弹出式，alt+7左下角窗口式（功能多）。                  |
| 28   | 复制当前行到下一行                      | ctrl+alt+方向键下            |                                                              |
| 29   | 快速从当前光标处开始新的一行            | shift+回车                   |                                                              |
| 30   | 代码格式化                              | 自定义为alt+shift+F          | 和 VS Code 一致                                              |
| 31   | 光标放置在方法参数 ( ) 中，查看形参信息 | 自定义为 ctrl+shift+M        | 键盘映射→主菜单→视图→形参信息中设置                          |
| 32   | 大小写转换                              | ctrl+shift+X/U/Y             |                                                              |
| 33   | 数组或者集合循环迭代                    | .for   .iter                 |                                                              |
| 34   | 打开环绕方式                            | ctrl+alt+T                   |                                                              |
| 35   | 方法折叠                                | ctrl+减号（小键盘）          | 或者ctrl+alt+大键盘减号                                      |
| 36   | 方法展开                                | ctrl+加号（小键盘）          | 或者ctrl+alt+大键盘加号                                      |
| 37   | 方法全部折叠                            | ctrl+shift+numpad/           | 可以自定义为ctrl+shift+大键盘减号                            |
| 38   | 方法全部展开                            | ctrl+numpad*                 | 可以自定义为ctrl+shift+大键盘加号                            |
| 39   | 在资源管理器中查看当前java文件          | 自定义ctrl+shift+L           | 键盘映射→其他→在资源管理器中显示（选第一个）                 |
| 40   | 模糊查询方法                            | ctrl+shift+alt+N             |                                                              |
| 41   | 全局查找                                | ctrl+H                       |                                                              |
| 42   | 当前类查找替换                          | ctrl+F                       |                                                              |
| 43   | 查找文件/类等                           | 双击shift                    |                                                              |
| 44   | 抽取方法                                | alt+shift+M                  | 改完默认方法名后  **按回车**  确认完成设置                   |
| 45   | 打开最近文件                            | ctrl+E                       |                                                              |
| 46   | 关闭当前窗口                            | ctrl+F4                      |                                                              |
| 47   | 关闭当前所有窗口                        | ctrl+shift+W                 |                                                              |
| 48   | 有选择的粘贴                            | ctrl+shift+V                 |                                                              |
| 49   | 跳到文件尾                              | ctrl+end                     | end：光标跳至当前行尾                                        |
| 50   | 跳到文件头                              | ctrl+home                    | home：光标跳至当前行头                                       |
| 51   | 跳至光标上次所处位置                    | alt+方向键左                 | 配合快捷键  ctrl+方向键左 使右                               |
| 52   | 跳至光标下次所处位置                    | alt+方向键右                 | 配合快捷键  ctrl+方向键左 使用                               |
| 53   | 当打开多个project的时候，向下一个切换   | ctrl+alt+]                   |                                                              |
| 54   | 当打开多个project的时候，向上一个切换   | ctrl+alt+[                   |                                                              |
| 55   | 将所选字母转换为大写                    | ctrl+shift+U                 |                                                              |

> 模版快捷键
>
> setting -> editor -> Live Templates 实时模版
>
> psvm  fori sout

# 包

> 包的三大作用
>
> 1. 区分相同名字的类
> 2. 当类很多时，可以很好的管理类［看Java API 文档］
> 3. 控制访问范围

> 包的基本语法
>
> `package com.hspedu;`
>
> package 表示打包
>
> com.hspedu 表示包名

> 包的本质分析——原理
>
> 包的本质实际就是 创建不同的文件夹来保持类文件。
>
> 两个包都有 Dog 类，第一个导入的可以不用加包名直接 `new Dog();`，但是第二个使用时必须要加包名了不然无法区分。

> 包的命名
>
> > 命名规则：
> >
> > <u>***只能包含数字、字母、下划线、小圆点。但不能用数字开头，不能是关键字或保留字***</u>
> > demo.class.exec1
> > demo.12a
> > demo.ab12.oa
>
> > 命名规范
> >
> > 一般是小写字母+小圆点一般是
> > com.公司名.项目名.业务模块名
> > 比如：`com.hspedu.oa.model;`    `com.hspedu.oa.controller：`
> >
> > > 举例：
> > > com.sina.crm.user //用户模块
> > > com.sina.crm.order // 订单模块
> > > com.sina.crm.utils //工具类

> 常用的包
>
> java.lang.*  //lang包是基本包，默认引入，不需要再引入.
> java.util.*    //util 包，系统提供的工具包，工具类，使用 Scanner
> java.net.*   // 网络包，网络开发
> java.awt.*  //是做java的界面开发，GUI

> 导入包
>
> 语法：import  包名
>
> 我们引入一个包的主要目的是要使用该包下的类
> 比如 import java.util.Scanner：就只是引入一个类Scanner。
> import java.util.*： // 表示将java.util 包所有都引入。
>
> 推荐用到那个 类 就导入哪个

> 包的注意事项和细节
>
> 1. package 的作用是声明当前类所在的包，需要放在类的最上面，一个类中最多只有一句package
>
> 2. import指令 位置放在package的下面，在类定义前面，可以有多句且没有顺序要求。

# 访问修饰符

> 基本介绍
>
> java提供四种访问控制修饰符号，**<u>*用于控制方法和属性（成员变量）的访问权限*</u>**（范围）：
> 1. 公开级别：用public 修饰，对外公开
> 2. 受保护级别：用protected修饰，对子类和同一个包中的类公开
> 3. 默认级别：没有修饰符号 或者 default，向同一个包的类公开.
> 4. 私有级别：用private修饰，只有类本身可以访问，不对外公开.

下图是java中对属性和方法 的访问修饰符总结，**<u>*类只有public和默认default两种。*</u>**![image-20240204下午41916955](/Users/yannlau/Library/Application Support/typora-user-images/image-20240204下午41916955.png)

> ![image-20240204下午42102940](/Users/yannlau/Library/Application Support/typora-user-images/image-20240204下午42102940.png)
>
> protected  不同包 但是是子类，可以直接访问！
>
> 使用注意事项
>
> 1） 修饰符可以用来修饰类中的属性，成员方法以及类
> 2） 只有默认default的和public才能修饰类！并且遵循上述访问权限的特点。
> 3）因为没有学习继承，因此关于在子类中的访问权限，我们讲完子类后，在回头讲解
> 4） 成员方法的访问规则和属性完全一样.

# 面向对象编程 —— 封装

封装（encapsulation）就是把抽象出的数据［属性］和对数据的操作［方法］封装在一起，数据被保护在内部，程序的其它部分只有通过被授权的操作［方法］，才能对数据进行操作。

> 封装的好处
>
> 1. 隐藏实现细节  方法（连接数据库） <-- 调用（传入参数。。）
> 2. 可以对数据进行验证，保证安全合理

> 封装的步骤
>
> 1） 将属性进行私有化【不能直接修改属性】
> 2） 提供一个公共的set方法，用于对属性判断并赋值
> public void setXxx（类型 参数名）｛
> 	//加入数据验证的业务逻辑
> 	属性 = 参数名；
> ｝
> 3） 提供一个公共的get方法，用于获取属性的值
> public XX getXxx（｛//权限判断
> return xx;
> }

> 构造器也可以调用 setter getter

# 面向对象编程——继承

继承：解决代码复用性问题！

继承可以解决代码复用，让我们的编程更加靠近人类思维，当多个类存在相同的属性(变量)和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过extends来声明继承父类即可。

> 继承的基本语法
>
> Class 子类名 extends 父类名{
>
> }
>
> 1)子类就会自动拥有父类定义的属性和方法
>
> 2)父类又叫 超类，基类。
>
> 3)子类又叫派生类。

![image-20240204下午62838615](/Users/yannlau/Library/Application Support/typora-user-images/image-20240204下午62838615.png)

> 继承给变成带来的便利
>
> 1)代码的复用性提高了
>
> 2)代码的扩展性和维护性提高了

> 继承的深入讨论和使用细节
>
> 1. 子类继承了所有的属性和方法，非私有的属性和方法可以在子类直接访问，但是私有属性和方法不能在子类直接访问，要通过父类提供公共的方法去访问
> 1. 子类必须调用父类的构造器，完成父类的初始化。子类构造器中第一句默认隐藏地写了一句 super() 调用了父类的无参构造器。
> 1. 当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中用 super 去指定使用父类的哪个构造器完成对父类的初始化工作，否则，编译不会通过。
> 1. 如果希望指定去调用父类的某个构造器，则显式地调用一下
> 1. super 在使用时，需要放在构造器第一行（super()-调用构造器 的这种语法  只能同样滴在构造器中使用）
> 1. super() 和 this() 都只能放在构造器第一行，因此这两个方法不能共存在一个构造器。
> 1. Java所有类都是 Object 类的子类。Object 是所有类的基类。
> 1. 父类构造器的调用不限于直接父类！将一直向上追溯到 Object类（顶级父类）。
> 1. 子类最多只能继承一个父类（指直接继承），即 Java 中是单继承机制。
> 1. 不能滥用继承，子类和父类之间必须满足 is-a 的逻辑关系。

> 继承的本质分析
>
> 当子类对象创建好后，建立查找关系！
>
> (1)首先看子类是否有该属性
> (2)如果子类有这个属性，并且可以访问，则返回信息
> (3)如果子类没有这个属性，就看父类有没有这个属性(如果父类有该属性，并且可以访问，就返回信息.)
> (4)如果父类没有就按照(3)的规则，继续找上级父类，直到0bject
>
> <u>***注意，查找过程存在覆盖机制！第一次找到父类有对应的属性，但是是 private，会直接报错。不会在继续向上找是否有可以访问的对应属性了。***</u>

> JVM 继承的内存布局
>
> ![image-20240204下午92530280](/Users/yannlau/Library/Application Support/typora-user-images/image-20240204下午92530280.png)

> 创建子类的过程是：先依次加载父类，对父类的字段在栈区先进行初始化，再加载子类的。

# super关键字

super代表父类的引用，用于访问父类的属性、方法、构造器。

> 基本语法
>
> 1. 访问父类的属性  super.属性名，但不能访问父类的private属性;
>
> 2. 访问父类的方法  super.方法名(参数列表);   不能访问父类的private方法
> 3. 访问父类的构造器(这点前面用过):super(参数列表);只能放在构造器的第一句，只能出现一句!

> super 细节
>
> 1. 调用父类的构造器 (分工明确，父类属性由父类初始化，子类的属性由子类初始化)
> 2. 当子类中有和父类中的成员(属性和方法)重名时，为了访问父类的成员，必须通过super。如果没有重名使用super、this、直接访问是一样的效果!
> 3. super.call()  会跳过本类直接从父类开始查找。即使本类存在 call()。
> 4. super的访问不限于直接父类，如果爷爷类和本类中有同名的成员，也可以使用super去访问爷爷类的成员；如果多个基类中都有同名的成员，使用super访问遵循就近原则。A->B->C。当然也需要遵守访问权限的相关规则

> 子类找cal方法时，call()和 this.call()  查找顺序是：
> 1）先找本类，如果有，则调用
> 2）如果没有，则找父类（如果有，并可以调用，则调用〕
> 3）如果父类没有，则继续找父类的父类，整个规则，就是一样的，直到 Object类。
> 提示：如果查找方法的过程中，找到了，但是不能访问，则报错。如果查找方法的过程中，没有找到，则提示方法不存在。

> 子类找cal方法时，super.call()  查找顺序是：
>
> 直接查找父类，其他的规则一样。

# super和 this 比较

![image-20240204下午110656848](/Users/yannlau/Library/Application Support/typora-user-images/image-20240204下午110656848.png)

# override 方法重写覆盖

简单的说：方法覆盖（重写）就是子类有一个方法，和父类们的某个方法的<u>***名称，返回类型、参数***</u>一样，那么我们就说子类的这个方法覆盖了父类的方法。

> 方法重写也叫方法覆盖，需要满足下面的条件：
>
> 1. 子类的方法的参数，方法名称，要和父类方法的参数，方法名称完全一样。
> 2. 子类方法的返回类型和父类方法返回类型一样，或者是父类返回类型的子类 比如 父类 返回类型是 Object ，子类方法返回类型是String
> 3. 子类方法不能缩小父类方法的访问权限

# 重写和重载的比较

![image-20240204下午113636586](/Users/yannlau/Library/Application Support/typora-user-images/image-20240204下午113636586.png)

# 面向对象编程——多态polymorphic

多态的目的仍然是提高代码的复用性。

<u>***方法或对象具有多种形态。***</u>是面向对象的第三大特征，多态是建立在封装和继承基础之上的。

> 多态的具体表现
>
> 1. 方法的多态：重写和重载就体现多态。
> 2. 对象的多态（核心 难点 重点）
>    1. 一个对象的编译类型和运行类型可以不一致
>    2. 编译类型在定义对象时，就确定了，不能改变
>    3. 运行类型是可以变化的
>    4. 编译类型看定义时=号的左边，运行类型看=号的右边

e.g. Animal animal = new Dog(); 【animal 的编译类型是 Animal，运行类型是 Dog】

e.g. animal = new Cat(); 【animal 的运行类型变成了 Cat，编译类型仍然是 Animal】

> 多态注意事项和使用细节
>
> 1. 多态的前提是 ：两个对象（类）存在继承关系
> 2. 多态的向上转型
>    1. 本质 ：父类的引用指向了子类的对象，这里的父类不仅仅指代直接父类，所有的父类都可以！
>    2. 语法：父类类型  引用名 = new 子类类型();
>    3. 特点：编译类型看左边，运行类型看右边。可以调用父类中的所有成员（需遵守访问权限限制），不能调用子类中特有的成员（因为编译器编译时看的是编译类型，编译器检查到父类没有该成员，会报错！）；最终运行效果看子类的具体实现！
>    4. YannLau：因此向上转型，只可以调用父类有且具有访问权限的成员和子类进行重写过的，且具有访问权限的成员，不能调用子类独有的成员和无权限访问的成员。
>    5. YannLau：这里也正说明了为什么子类中对父类的方法成员重写必须要访问权限只能大于等于父类。如果父类的一个方法是 public 的，你用了向上转型指向一个子类，并对其调用该方法，编译器认为可以访问到会通过编译。但是子类中重写的方法却是 private 的。运行时看的是实际类型，在子类中先查找该方法，结果却发现是私有的不可以访问，这样会导致错误！编译器认为本来可以访问的调用结果被截胡了！所以规定权限必须大于等于父类方法。
> 3. 多态的向下转型
>    1. 语法： 子类类型 引用名 = (子类类型) 父类引用;
>    2. 只能强转父类的引用，不能强转父类的对象
>    3. 要求父类的引用必须指向的（下面的是 Son）是当前目标类型（指代 Father）的对象（或者子类对象，见下方代码）
>    4. 可以调用子类类型中所有的成员
>
> ```java
> //这样是被允许的！
> Grandpa grandpa = new Son();
> Father father = (Father) grandpa;
> ```

> 多态注意事项和细节讨论
>
> 1. <u>***属性没有重写之说***</u> ！查找属性的值要看编译类型！
> 2. instanceof 比较操作符，用于判断对象的 <u>***运行类型***</u> 是否为 XX 类型或者 XX 类型的子类型。如果跟无关的类比较会直接报错！只能用于有继承关系的类对象之间的比较。或者 `null instanceof AClassName 为 false`
> 3. <u>***instanceof 的使用：一般是将一个类的对象传给一个 Object 类的引用（形参），然后用该引用（形参）和目标类进行判断的。***</u>这样不管怎样都不会报错了。

# Java 的动态绑定机制（重要）

> Java 的动态绑定机制
>
> 1. 当调用对象的方法的时候，该方法会和该对象的内存地址/运行类型绑定（<u>***这样会导致，调用一个父类才有的方法时，这个父类方法主体中如果又调用了另一个方法（父类中肯定有该方法，至少父类的父类们会有，不然不能通过编译，且子类可能重写了该方法），它不会直接使用父类中的该方法，他会先去实际的运行类——子类中去找有没有该方法！这又是一个为什么子类的方法重写要比父类方法访问权限范围更大或者相等的原因！***</u>）
> 2. <u>***当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用（不会再跑到子类中找找看有没有了，不会优先使用子类的属性了）***</u>

# 多态的应用

> 数组的定义类型为父类类型，里面保存的实际元素类型为子类类型。

```java
if(persons［i］ instanceof Student)｛//判断person［i］ 的运行类型是不是Student
	Student student =（Student）persons［i］；//向下转型
	student.study) ;
	//小伙伴也可以使用一条语句（（Student）persons［i］）.study（）；
} else if(persons[i] instanceof Teacher) {
	Teacher teacher = (Teacher) persons[i];
	teacher. teach);
} else if(persons[i] instanceof Person){
}else{
  System.out.println("你的类型有误，请检查");
}
```

> 多态参数
>
> 方法定义的形参类型为父类类型，实参类型允许为子类类型。

# Object 类的详解

> equals 方法
>
> 1. equals 和 == 的对比
>
>    1. ==：既可以判断基本类型，又可以判断引用类型。判断引用类型时，== 两端的类型要相同。
>
>    2. ==：如果判断基本类型，判断的是值是否相等。示例：int i=10:double d=10.0；i == d 为 true
>
>    3. ==：如果判断引用类型，判断的是地址是否相等，即判定是不是同一个对象
>
>    4. equals: 是Object类中的方法，只能判断引用类型，
>
>    5. 默认判断的是地址是否相等，子类中往往重写该方法，用于判断内容是否相等。
>
>    6. Object原有的 equals 方法相当于 ==。
>
>    7. ```java
>       String s1 = "123";
>       String s2 = "123"；
>       s1 == s2 // true
>       s1.equals(s2); //true 
>                            
>       String s3 = new String("123");
>       String s4 = new String("123");
>       s3 == s4 // false
>       s3.equals(s4) // true
>       ```
>
> 2. hashCode 方法
>
>    1. 提高具有哈希结构的容器的效率！
>    2. 两个引用，如果指向的是同一个对象，则哈希值肯定是一样的！（可能碰撞但概率很低）
>    3. 两个引用，如果指向的是不同对象，则哈希值是不一样的。
>    4. 哈希值主要根据地址号来的！不能完全将哈希值等价于地址。
>    5. 后面在集合中 hashCode 如果需要的话，也会重写
>
> 3. toString 方法
>
>    1. 默认返回：全类名（getClass().getName）+@+哈希值的十六进制（  Integer.toHexString(hashCode())  ），子类往往重写toString方法，用于返回对象的属性信息
>    2. 当直接输出一个对象时，toString 方法会被默认的调用，比如直接打印对象引用。
>
> 4. finalize 方法
>
>    1. 当对象被回收时，系统自动调用该对象的finalize方法。子类可以重写该方法，做一些释放资源的操作。
>
>    2. 什么时候被回收：当某个对象没有任何引用时，则 JVM 就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销毁该对象前，会先调用finalize方法。
>
>    3. 垃圾回收机制的调用，是由系统来决定（即有自己的 GC 算法），也可以通过`System.gc()`主动触发垃圾回收机制，但也不是说一定能够立即清理掉。并且java 是多线程了，它调用 `System.gc()`，并不会等待清理，而是直接往下运行，所以可能运行中途才执行 finalize 中的操作。
>
>    4. ```java
>      
>      public class Finalize_ {
>      	public static void main(String[] args) {
>      		Car bmw = new Car("宝马");
>      	//这时 car对象就是一个垃圾，垃圾回收器就会回收（销毁）对象，在销毁对象前，会调用该对象的finalize方法
>      	//程序员就可以在 finalize中，写自己的业务逻辑代码（比如释放资源：数据库连接，或者打开文件。〕
>      	//如果程序员不重写finalize，那么就会调用 Object类的 finalize，即默认处理
>      	//如果程序员重写了finalize，就请以实现自己的逻辑
>      		bmw = null;
>          System.gc();//主动调用垃圾回收器	
>          System.out.println（"程序退出了..."）;
>      	}
>      }
>      
>      class Car {
>      	private String name;
>      	//属性，资源。。
>      	public Car(String name) {
>      		this.name = name;
>        }
>      	//重写finalize
>      	@Override
>      	protected void finalize) throws Throwable {
>      		System.out.println("我们销毁 汔车" + name);
>      		system.out.println("释放了某些资源...");
>        }
>      }
>      ```
>                     
>    5. 老韩提示：我们在实际开发中，几乎不会运用 finalize，所以更多就是为了应付面试。

# Integer 和 ==

```java
jshell> Integer i1 =12
i1 ==> 12

jshell> Integer i2 =12
i2 ==> 12

jshell> i1 == i2
$3 ==> true

jshell> i1 = 111111111
i1 ==> 111111111

jshell> i2 = 111111111
i2 ==> 111111111

jshell> i1 == i2
$6 ==> false
```

# Integer 和 Object

```java
jshell> int a =21
a ==> 21

jshell> Object o = new Object()
o ==> java.lang.Object@30dae81

jshell> o = a
o ==> 21

jshell> o instanceof Integer
$9 ==> true
  
jshell> o.getClass()
$10 ==> class java.lang.Integer
```

# 断点调试 debug

1. 在开发中，新手程序员在查找错误时，这时老程序员就会温馨提示，可以用断点调试，一步一步的看源码执行的过程，从而发现错误所在。
2. 重要提示：在断点调试 过程中，是运行状态，是以对象的 运行类型来执行的。

> 断点调试简介
>
> 1. 断点调试是指在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后你可以一步一步往下调试，调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。
> 2. 进行分析从而找到这个Bug断点调试是程序员必须掌握的技能。
> 3. 断点调试也能帮助我们查看java底层源代码的执行过程，提高程序员的Java水平。

![image-20240205下午54002668](/Users/yannlau/Library/Application Support/typora-user-images/image-20240205下午54002668.png)

断点 可以在 debug 过程中 动态地下断点。也支持 JDK 的源码中下断点。`resume`也可以用来判断是否业务逻辑会运行到某一段代码中。如果运行不到那里的话，就算打了断点也会直接跳过去。

