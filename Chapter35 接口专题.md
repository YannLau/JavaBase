# 接口 interface

> 接口就是给出一些没有实现的方法，封装到一起，到某个类要使用的时候，在根据具体情况把这些方法写出来。语法：
>
> `interface 接口名{`
>
> ​	`//属性`
>
> ​	`//方法`
>
> `}`
>
> `class 类名 implements 接口1,接口2,接口3{`
>
> ​	`//自己属性`
>
> ​	`//自己方法`
>
> ​	`//必须实现的接口抽象方法`
>
> `}`
>
> 小结：
>
> 1. 在Jdk7.0前 接口里的所有方法都没有方法体。即都是抽象的方法（一般不写 abstract 关键字）。在接口中，抽象方法，可以省略 abstract 关键字。
> 2. Jdk8.0后接口类可以有静态方法，默认方法（default 修饰——default 放在访问修饰符前面），也就是说接口中可以有方法的具体实现。

> 接口的深入讨论
>
> 对初学者讲.理解接口的概念不算太难，难的是不知道什么时候使用接口，下面我例举几个应用场景：
>
> 1. 说现在要制造战斗机，武装真升机.专家只需把飞机需要的功能/规格定下来即可，然后让别的人具体实现就可。
>
> 2. 说现在有一个项目经理.管理三个程序员，功能开发一个软件，为了控制和管理软件，项目经理可以定义一些接口，然后由程序员具体实现。
>
>   实际要求：3个程序员，编写三个类，分别完成对Mysql,Oracle,DB2数据库的连接。

> 接口的注意事项和细节
>
> 1）接口不能被实例化
> 2）接口中所有的方法是 public方法，不写访问修饰符也是默认为 public，接口中抽象方法，可以不用abstract 修饰 `public void aaa();  等价于    public abstract void aaa();`不用加花括号！
> 3） 一个普通类实现接口，就必须将该接口的所有方法都实现。
> 4） 抽象类实现接口，可以不用实现接口的方法。
> 5） 一个类同时可以实现多个接口
> 6）接口中的属性，只能是final的，而且是 public static final 修饰符。比如：int a=1；实际上是 `public static final` int a=1;（必须初始化）
> 7） 接口中属性的访问形式：`接口名.属性名`
> 8） 一个接口不能继承其它的类，但是可以继承多个别的接口 `interface A extends B,C {}`
> 9)接口的修饰符 只能是 public 和 默认，这点和类的修饰符是一样的。

# 接口 VS 继承类

小结：当子类继承了父类，就自动的拥有父类的功能
如果子类需要扩展功能，可以通过实现接口的方式了扩展。

可以理解 实现接口 是 对 java 单继承机制的一种补充。

> 接口和继承解决的问题不同
>
> 1. 继承的价值主要在于：解决代码的复甩性和可维护性。
>
> 2. 接口的价值主要在于：设计，设计好各种规范（方法），让其它类去实现这些方法。
>
> 接口比继承更加灵活
>
> 1. 接口比继承更加灵活，继承是满足 is-a的关系，而接口只需满足like-a的关系。
>
> 接口在一定程度上实现代码解耦【即 接口规范性 + 动态绑定】

# 接口的多态性

1） 多态参数（前面案例体现）InterfacePolyParameter.java
在前面的Usb接口案例，`Usblnterface usb`，既可以接收手机对象，又可以接收相机对象，就体现了 接口 多态（接口引用可以指向实现了接口的类的对象）。

> 接口类型的变量 可以指向 实现了该接口的类的对象

2） 多态数组 InterfacePolyArr.java
演示一个案例：给Usb数组中，存放 Phone 和 相机对象， Phone类还有一个特有的方法call()。请遍历Usb数组，如果是Phone对象，除了调用Usb 接口定义的方法外，还需要调用 Phone 特有方法 call。

3）接口存在多态传递现象.InterfacePolyPass.java

> 1. 接口类型的变量可以指向，实现了该接口的类的对象实例
> 2. 如果A接口继承了另一个B 接口。而类 C 实现了 A 接口，就相当于类 C也实现了 B 接口，那么，B 接口引用变量可以用来指向 类C 的实例对象。这就是接口的多态传递现象！

当一个对象访问一个父类和实现的接口都有的变量时，用 super.变量名指定父类变量，用 接口名.变量名指代接口变量，避免混淆，否则编译器会报错！