p63——p103

[toc]

# / % ++

整形 / 整形 = 整形（就算与小数也要截断）

```java
10 / 4 = 2
10.0 / 4 = 2.5
double d = 10 / 4; // d=2.0  10/4=2 2->2.0

//易错！
-10/3=-3
10/3=3
```

%取模=取余数

在 Java 中 % 的本质 是一个公式 `a % b = a - a / b * b`

被除数 - 商 ✖️ 除数 = 余数 = 模

```java
jshell> 10%3
$9 ==> 1

jshell> -10%3  //被模数是负数，余数是负数
$10 ==> -1

jshell> 10%-3  // 被模数是正数，余数是正数
$11 ==> 1
  
jshell> -10%-3
$2 ==> -1
```

通过以上学习我发现一个容易理解的方法：

> 所有的 整形除法  运算中，如果含有负数的运算，完全可以将 `符号位` 提出去。计算正值运算的结果，最后将符号位添加即可。如果是负负的情况，直接负负得正，当做正数计算即可！

1. 面试题1

   ```java
   int i=1://i->1
   i=i++;  //规则使用临时变量:(1) temp=i; (2)i=i+1;(3)i=temp;
   System.out.println(i);//
   问:结果是多少?为什么?
     
     答案是 1 
   ```

2. 面试题 2

   ```java
   int i=1;
   i=++i; //规则使用临时变量:(1)i=i+1;(2)temp=i;(3)i=temp;
   System.out.println(i); //2
   ```

# 关系运算符

instanceof

== !=

<=  <

\>=  <

# 逻辑运算符

短路  与 &&  或 ||   取反 !

逻辑  与 &    或 |     逻辑异或 ^

![image-20240201下午115442627](/Users/yannlau/Library/Application Support/typora-user-images/image-20240201下午115442627.png)

> &&和&使用区别     ||和|区别同理
>
> &&短路与:如果第一个条件为false，则第二个条件不会判断，最终结果为false
>
> & 逻辑与:不管第一个条件是否为false，第二个条件都要判断，效率低。
>
> 开发中，我们使用的基本是短路与&&，效率高

# 赋值运算符

基本赋值运算符  =

复合赋值运算符  += -= /= %= *=

> 赋值运算符特点
>
> 1)运算顺序从右往左 int num = a+b+c;
>
> 2)赋值运算符的左边 只能是变量,右边 可以是变量、表达式、常量值int num =20;   intnum2=78*34-10;   int num3 =a;
>
> 3)复合赋值运算符等价于下面的效果比如:a+=3;等价于a=a+3;
>
> 4)复合赋值运算符会进行类型转换。byte b=2; b+=3; b++;（不会发生 int->byte 错误）
>
> `说明 a+=3 和 a=a+3还是不完全一样的！`
>
> `其实 a+=b 等价于 a = (type_of_a)(a + b)，有一个强制转换的过程`
>
> ```java
> jshell> byte c = 3
> c ==> 3
> 
> jshell> int a =2
> a ==> 2
> 
> jshell> c+=a
> $14 ==> 5
> 
> jshell> c
> c ==> 5
> 
> jshell> c=c+a
> |  错误:
> |  不兼容的类型: 从int转换到byte可能会有损失
> |  c=c+a
> |    ^-^ 
> ```

# 三元运算符TernaryOperator

> 基本语法
>
> 条件表达式 ? 表达式1 : 表达式2;
>
> 运算规则:
>
> 1.如果条件表达式为true，运算后的结果是表达式1;
>
> 2.如果条件表达式为false，运算后的结果是表达式2;
>
> 口诀:[一灯大师：一真大师]

```java
int a= 10;
int b =99;
//解读
//a>b 为 falsel
//2.返回 b--，先返回 b的值,然后在 b-1
//3.返回的结果是99, a++不会计算，a 仍然是 10 而不是 11
int result =a > b ? a++ : b--;
System.out.println("result=" + result);
```

1. 表达式1 和 表达式2 要为可以赋给接收变量的类型(或可以自动转换)  **<u>*注意：这里的表达式的值的类型会在编译时进行检查！*</u>**

2. 三元运算符可以转成 if--else 语句
   `int res = a > b ? a++ : --b;`

   `if (a>b){`

   ​	`res = a++;`

   `}else{`

   ​	`res = --b;`

   `}`

# 运算符优先级

1. 运算符有不同的优先级，所谓优先级就是表达式运算中的运
    算顺序。如右表，上一行运算符总优先于下一行。
2. 只有单目运算符、赋值运算符是从右向左运算的。
3. 梳理小结：小伙伴有一个大致印象，使用多
    了，就熟悉
    1）( ),{ }等
    2） 单目运行 ++ --
    3） 算术运算符
    4） 位移运算符
    5） 比较运算符
    6） 逻辑运算符
    7） 三元运算符
    8） 赋值运算符

| 优先级:高->低 | .  ()  {}  ;  ,                   |
| ------------- | --------------------------------- |
| R->L          | ++  --  ~(按位取反)  !(data type) |
| L->R          | *  /  %                           |
| L->R          | +  -                              |
| L->R          | <<  >>  >>>  位移                 |
| L->R          | <  >  <= >=  instanceof           |
| L->R          | ==  !=                            |
| L->R          | &                                 |
| L->R          | ^                                 |
| L->R          | \|                                |
| L->R          | &&                                |
| L->R          | \|\|                              |
| L->R          | ? :                               |
| R->L          | =  *=  /=  %=                     |
|               | +=  -=  <<=  >>=                  |
|               | >>>=  &=  ^=  \|=                 |

> ~ 按位取反
>
> 将目标数换算成其类型相应大小的二进制表示，然后每一位取反，在计算值。
>
> 在Java中，按位取反操作符 `~` 适用于整数类型。具体来说，它可以用于以下整数类型：
>
> 1. **int：** `~` 可以应用于 `int` 类型的整数。
>
>    ```java
>    int x = 5;
>    int result = ~x;
>    ```
>
> 2. **long：** `~` 也可以应用于 `long` 类型的整数。
>
>    ```java
>    long y = 10L;
>    long resultLong = ~y;
>    ```
>
> 3. **short 和 byte：** 在应用 `~` 操作符时，Java 会自动将 `short` 和 `byte` 类型的操作数转换为 `int` 类型，然后执行按位取反操作。
>
>    ```java
>    short s = 100;
>    byte b = 7;
>    int resultShort = ~s;
>    int resultByte = ~b;
>    ```
>
> 请注意，按位取反操作符 `~` 执行对每个比特位的取反操作。即，它将每个 0 变为 1，每个 1 变为 0。这可能在一些场景下用于特定的位操作需求。

# 标识符的命名规则和规范

概念1

1. Java 对各种变量、方法和类等命名时使用的字符序列称为标识符
2. 凡是自己可以起名字的地方都叫标识符 int num1 = 90：

概念2：

​	用来给`类、变量、方法、接口、对象、自定义数据类型`命名的标识，称作标识符。

命名规则（必须遵守的）

1. 命名规则

- 标识符由任意顺序的`大小写字母 数字 下划线_ 美元符号$` 组成
- 标识符`不能以数字开头`
- 标识符`长度任意，无限制`
- 标识符`区分大小写`
- 标识符`中间不能有空格`
- 标识符`不能是Java的关键字` 如class void，但是可以包含关键字，如class1 int2 abcalss

命名规范（更加专业）

1. 包名：多单词组成时所有字母都小写：aaa.bbb.ccc //比如 com.hsp.crm
2. 类名、接口名：多单词组成时，所有单词的首字母大写：XxxxYyyZzz［大驼峰］比如：TankShotGame
3. 变量名、方法名：多单词组成时，第一个单间首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz  【小驼峰，简称驼峰法】比如：tankShotGame
4. 常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ  比如：定义一个所得税率 TAX_RATE
5. 后面我们学习到类，包，接口，等时，我们的命名规范要这样遵守，更加详细的看文档。

# 关键字

1. 概念:Java关键字是事先定义好的，对Java编译器有着特殊含义的标识符，是编译器和程序员的一个约定，用来表示一种数据类型或者是程序结构，或者是操作指令等等。关键字不能作为用户自定义标识符来使用。

2. 特点：关键字中的所有字母都为小写

3. 关键字列表

   1. 用于定义数据类型的关键字

      > boolean、byte、char、double、float、int、long、short、class、interface、enum、void

   2. 用于定义数据类型值的关键字

      >false、true、null

   3. 用于定义流程控制的关键字

      > if、else、switch、case、default、while、do、for、break、continue、return

   4. 用于定义访问权限修饰符的关键字

      >private、public、protected

   5. 用于定义类、函数、变量修饰符的关键字

      > abstract、final、static、synchronized

   6. 用于定义类与类之间关系的关键字

      > extends、implements

   7. 用于定义建立实例及引用实例，判断实例的关键字

      > new、this、super、instanceof

   8. 用于异常处理的关键字

      > catch、throw、throws、finally、try

   9. 用于包的关键字

      > package、import

   10. 其他修饰符关键字

       > native、transient、volatile、assert、strictfp

4. 保留字
   1. Java保留字：现有Java版本尚未使用，但以后版本可能会作为关键字使用。自己命名标识符时要避免使用这些保留字
   2. *<u>**const、goto**</u>*、(这两个是不能使用的)  byValue、cast、future、generic、inner、operator、outer、rest、var

**以上除了 const、goto 不可以使用， 其他的可以声明变量其目前不是关键字，可以用来做标识符**。

# 导包操作

`import java.util.Scanner;`

# 进制与转换

> 进制的计算机表示

二进制 0b 或者 0B 开头。

八进制 数字 0 开头。

十六进制 0x 或 0X 开头 ，A-F 不区分大小写！

> 进制转换

1. 第一组
   - 二进制 -> 十进制
   - 八进制 -> 十进制
   - 十六进制 -> 十进制

2. 第二组
   - 十进制 -> 二进制
     - 短除法-规则：将该数不断除以2，直到商为0为止，然后将每步得到的余数倒过来，就是对应的二进制。
   - 十进制 -> 八进制
     - 仍然是短除法：除以8
   - 十进制 -> 十六进制
     - 仍然是短除法：除以 16，注意——余数要写成十六进制的形式！
3. 第三组
   - 二进制转八进制
     - 规则：从低位开始，将二进制数每三位一组，转成对应的八进制数即可。
   - 二进制转十六进制
     - 规则：从低位开始，将二进制数每四位一组，转成对应的十六进制数即可。
4. 第四组
   - 八进制、十六进制转成二进制
     - 规则：将八进制数每1位，转成对应的一个3位的二进制数即可。
     - 规则：将十六进制数每1位，转成对应的一个4位的二进制数即可。

# 原码 反码 补码

1. 二进制的最高位是符号位：0表示正数，1表示负数（老韩口诀：0 -> 0 1 -> -）
2. 正数的原码，反码，补码都一样（三码合一）
3. 负数的反码 = 它的原码符号位不变，其它位取反（0->1,1->0）
4. 负数的补码=它的反码+1，负数的反码= 负数的补码- 1
5. 0的反码，补码都是0

6. java没有无符号数，换言之，java中的数都是有符号的
7. <u>***在计算机运算的时候，都是以补码的方式来运算的***</u>。包括 位运算 也是针对数值的补码进行计算的！计算的结果也存储为 补码 !
8. 当我们看运算结果的时候，要看他的原码



# 位运算符

位运算符的本质是对整形数据在内存中的实际存储 bit 进行操作（补码）。

- java中有7个位运算（&、 、^、~、 >>、 << 和 >>>）
- 分别是 按位与 &、按位或 |、按位异或 ^，按位取反 ~，它们的运算规则是：
  - 按位与＆两位全为1，结果为1，否则为0
  - 按位或 | 两位有一个为1，结果为1，否则为0
  - 按位异或^：两位一个为0，一个为1，结果为1，否则为0
  - 按位取反~：0->1, 1->0
  - \>> 算数右移 : 低位溢出，符号位不变，并用符号位补溢出的高位
    - 3>>3  本质是 3/$2^3$
  - << 算数左移：<u>***符号位不变(符号位溢出的话就不管了)***</u>，低位补0
    - 3<<3 本质是 3*$2^3$
  - \>>> 逻辑右移也叫无符号右移，运算规则是：低位溢出，高位补 0
  - 特别说明：没有 <<< 符号


Java 的位运算符是用于整数类型的操作，而不是浮点类型。位运算符包括 AND（&）、OR（|）、XOR（^）、左移（<<）、右移（>>）和无符号右移（>>>）等。这些运算符只能用于整数类型，包括 byte、short、int、long、char 等。

如果你尝试对浮点类型使用位运算符，Java 编译器会报错。例如：

```java
float a = 10.5f;
float b = 5.2f;

// 下面的代码会导致编译错误
// float result = a & b;
// float result2 = a << 2;
```

在这个例子中，尝试使用位运算符对浮点数进行运算会导致编译错误，因为位运算符要求操作数是整数类型。

如果你需要对浮点数进行位级别的操作，你可能需要考虑将浮点数转换为整数类型，执行位运算，然后再将结果转回浮点数。但要小心，因为这可能导致精度丢失或不符合预期的结果。通常情况下，浮点数的位运算并不是一个常见的需求。

> 理清楚 位运算符的 模问题 待完成
>
> 
