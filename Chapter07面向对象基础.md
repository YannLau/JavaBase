P192——P263

[toc]

# JVM内存中对象存在的形式

![image-20240203下午54621287](/Users/yannlau/Library/Application Support/typora-user-images/image-20240203下午54621287.png)

# 类与对象

*<u>**一个java文件可以写一个类或多个类，当只写一个类的时候，可以是 public 也可以是 默认访问权限，当是 public 时，类名必须与文件名相同。如果不是 public 的话，名字不需要和文件名一致！**</u>*

> 属性 / 成员变量 / field字段都指的是类内定义的变（常）量。

> 注意事项和细节说明
>
> 1）属性的定义语法同变量
>
> 示例：访问修饰符 属性类型 属性名：
>
> 2）属性的定义类型可以为任意类型，包含基本类型或引用类型
>
> 3）属性如果不赋值，有默认值，规则和数组一致。



> 类和对象分配机制
>
> Java内存的结构分析
> 1. 栈：一股存放基本数据类型（局部变量）
> 2. 堆：存放对象（Cat cat，数组等）
> 3. 方法区：常量池（常量，比如字符串，这里存放的字符串是实例对象中 String 字段的值），类加载信息



> Java 创建对象的流程简单分析
>
> 1. 先加载Person类信息（属性和方法信息，只会加载一次）
> 2. 在堆中分配空间，进行默认初始化（看规则）
> 3. 把地址赋给 p
> 4. 进行指定初始化  p.name="Jack".....



> Java 声明一个字符串 String 并且赋值"xxx"。那么它存放在哪里？堆区还是栈区还是方法区？
>
> ChatGPT
>
> 在Java中，字符串对象通常存放在字符串常量池中，而字符串常量池位于方法区（也称为永久代，或在较新的Java版本中称为元空间）中。当你声明一个字符串并赋值时，如果字符串的内容在字符串常量池中不存在，它会被添加到常量池中，并且后续对相同内容的字符串的引用将指向同一个字符串对象。
>
> 需要注意的是，<u>***Java中的字符串是不可变的，即一旦创建就不能被修改。当你对字符串执行一些操作时，实际上是创建了新的字符串对象。***</u>
>
> 关于栈和堆：
>
> - 栈：Java中的基本数据类型和对象的引用变量存储在栈上。当你在方法中声明一个变量时，这个变量通常会被分配到栈上。但是，字符串对象本身不是存储在栈上的，而是存储在堆中或字符串常量池中。
> - 堆：对象实例和数组等动态分配的内存通常存储在堆上。在字符串的情况下，字符串对象可以存储在堆中，尤其是通过`new`关键字创建的字符串对象。
>
> 总的来说，字符串常量池位于方法区，而具体的字符串对象可能存储在字符串常量池中或堆中，具体取决于字符串的创建方式。



> 成员方法
>
> ![](/Users/yannlau/Library/Application Support/typora-user-images/image-20240203下午64945932.png)

> 成员方法的好处
>
> 提高代码的复用性。
> 可以将实现的细节封装起来，然后供其他用户来调用即可。

> 成员方法的细节
>
> 1. 访问修饰符（作用是控制方法使用的范围）
>
>    如果不写默认访问，［有四种：public, protected， 默认default，private］，具体在后面说
>
> 2. 返回数据类型
>
>    1. 一个方法最多有一个返回值［思考，如何返回多个结果 返回数组］
>
>    2. 返回类型可以为任意类型，包含基本类型或引用类型（数组，对象）
>    2. 如果方法要求有返回数据类型，则方法体中最后的执行语句必须为return 值；而且要求返回值类型必须和return的值类型一致或兼容。
>    2. 如果方法是void，则方法体中可以没有return语句，或者 只写 return；
>
> 3. 方法名
>
>    1. 遵循驼峰命名法，最好见名知义，表达出该功能的意思即可，比如 得到两个数的和getSum， 开发中按照规范。
>
> 4. 形参列表
>
>    1. 一个方法可以有0个参数，也可以有多个参数，中间用逗号隔开，比如 getSum(int n1,int n2)
>
>    2. 参数类型可以为任意类型，包含基本类型或引用类型，比如 printArr(int[\][\] map)
>    3. 调用带参数的方法时，一定对应着参数列表传入相同类型或兼容类型的参数！
>    4. 方法定义时的参数称为形式参数，简称形参；方法调用时的参数称为实际参数，简称实参，实
>        参和形参的类型要一致或兼容、个数、顺序必须一致!
>
> 5. 方法体
>
>   1. 里面与完成功能的具体的语句，可以为输入、输出、变量、运算、分支、循环、方法调用，但里
>
>     面不能再定义方法！即：方法不能嵌套定义。
>
> 6. 方法细节调用说明
>
>   1. 同一个类中的方法调用：直接调用即可。
>   2. 跨类中的方法  A类调用B类方法：需要通过对象名调用。比如 对象名.方法名（参数）；
>   3. 特别说明一下：跨类的方法调用和方法的访问修饰符相关，先暂时这么提一下，后面我们讲到访问修饰符时，还要再细说。

# 方法传参机制

基本数据类型传参机制 —— 传的是形参

引用类型传参机制 —— 传的是形参，但内容实质是一个指针

# 方法重载Overload

> 重载的好处
>
> 1） 减轻了起名的麻烦
> 2） 减轻了记名的麻烦

> 重载的注意事项和细节
>
> 方法名：必须相同
>
> 形参列表：必须不同（形参类型 或 个数 或 顺序，至少有一样不同，参数名无要求）
>
> 返回类型：无要求，只有返回类型不同不能构成方法重载！

```java
//以下两个方法构成方法重载
31.0 78.3 18 会优先匹配第二个，因为 18 不需要自动类型转换，优先级更高

public double max(double n1,double n2,double n3){

}

public double max(double n1,double n2,int n3){

}
```

# 可变参数

基本概念：

Java 允许将同一个类中多个同名同功能但参数个数不同的方法，封装成一个方法。可以通过可变参数实现！

基本语法：

访问修饰符 返回类型 方法名（数据类型... 形参名）{

}

```java
public int sum(int... parameters){
  int length = parameters.length;
}
1. int... 表示接受的是可变参数，类型是 int，即可接收多个 int（0——多个）
2. 使用可变参数时，可以当做数组来使用，即 parameters 可以当做数组来使用
3. 可以直接 int[] array = {1,2,3,3,4}  
								sum(array); 这是合法的！！！
```

> 注意事项
>
> 1）可变参数的实参可以为0个或任意多个。
> 2） 可变参数的实参可以为数组。
> 3） 可变参数的本质就是数组.
> 4）可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后
> 5） 一个形参列表中只能出现一个可变参数

# 作用域

面向对象中，变量作用域是非常重要知识点

1. 在java编程中，主要的变量就是属性（成员变量）和局部变量。
2. 我们说的局部变量一般是指在成员方法中定义的变量。

3. java中作用域的分类

  全局变量：也就是属性，作用域为整个类体，如Cat类：cry eat 等方法使用属性
  局部变量：也就是除了属性之外的其他变量，作用域为定义它的代码块中！

4. 全局变量-属性 可以不赋值，直接使用，因为有默认值。

  <u>***局部变量必须赋值后，才能使用，因为没有默认值。***</u>

> 细节
>
> 1. <u>***属性 和 局部变量 可以重名，访问时遵循就近原则。***</u>
>
> 2. 在同一个作用域中，比如在同一个成员方法中，两个局部变量，不能重名。
> 3. 属性生命周期较长，伴随着对象的创建而创建，伴随着对象的死亡而死亡。
> 4. 局部变量，生命周期较短，伴随着它的代码块的执行而创建，伴随着代码块的结束而死亡。即在一次方法调用过程中。
> 5. 作用域范围不同
>    全局变量/属性：可以被本类使用，或其他类使用（通过对象调用）
>    局部变量：只能在本类中对应的方法中使用
> 5. 修饰符不同
> 全局变量/属性可以加修饰符
> 局部变量不可以加修饰符

# 构造器

主要作用：新对象的初始化！

基本语法

`[修饰符] 方法名(形参列表){`

​	`方法体`

`}`

1） 构造器的修饰符可以默认、public、protected、private
2） 构造器没有返回值 也不能写 void
3） 方法名 和 类名字 必须一样
4） 参数列表 和 成员方法 是一样的规则
5） 构造器的调用系统完成。

>细节
>
>1. 一个类可以定义多个不同的构造器，即**<u>*构造器重载*</u>**
>     比如：我们可以再给Person类定义一个构造器，用来创建对象的时候，只指定人名，不需要指定年龄
>2. 构造器名和类名要相同
>3. 构造器没有返回值
>4. 构造器是完成对象的初始化，并不是创建对象
>5. 在创建对象时，系统自动的调用该类的构造方法
>6. 如果程序员没有定义构造方法，系统会自动给类生成一个默认无参构造方法（也叫默认构造方法），比如 Person(){}，使用 javap指令 反编译看看
>7. 一旦定义了自己的构造器，默认的构造器就覆盖了，就不能再使用默认的无参构造器，除非显式的定义一下，即：`Person（）{}`
# javap 反编译工具

对 .class 文件进行反编译

# 对象创建的流程分析

第一次对一个类进行实例化的时候的流程:

1. 在方法区中 加载 类 信息，e.g. Person.class
2. 在堆区开辟空间，用于存放对象信息，得到对象在堆区中的地址
3. 构造器对 实例对象 的字段初始化。其中 字符串 和 常量 放在常量池。
4. 对象在堆区中的地址返回给栈中的类变量。对象真正的本体存放在堆区中，栈区的 类变量 只是对象的引用。

# this

指代实例对象本身。用于指代当前对象的属性和方法。

用于方法的形参和属性名相同时初始化赋值会造成复制失效，实例字段都会是默认值，而没有成功赋值！

this 的本质是一个堆区中的一个隐藏属性。

![image-20240204上午111000523](/Users/yannlau/Library/Application Support/typora-user-images/image-20240204上午111000523.png)

> this 使用细节
>
> 1. this关键字可以用来访问本类的属性、方法、构造器
> 2. this用于区分当前类的属性和局部变量
>
> 3. 访问成员方法的语法：this.方法名（参数列表）；
> 4. 访问构造器语法：this（参数列表）：注意只能在一个构造器中使用，即只能在构造器中访问调用另一个构造器。<u>***且必须置于构造器中的第一行。这也说明了构造器之间的相互调用最多只能一次。***</u>
> 5. this不能在类定义的外部使用，只能在类定义的方法、构造器中使用。

`this.function();`

`function();`

上面两种写法是不同的，具体差别在继承中才学。

传统方式的不加 this 的变量使用是遵从就近原则的。先找局部变量看有没有，没有再找 类字段。加完 this 直接找类字段。

# HW1

```java
public class Homework01 {
//编写一个main方法
	public static void main(String[] args) {
		A01 a01 = new A010;
		double[] arr = null; //;(};
		Double res = a01. max (arr);
		if(res != null) {
			System.out.println（"arr的最大值=" + res）；
		｝ else｛
			System.out.println（"arr的输入有误，数组不能为 null，或者{}"）；
		｝
	｝
}
  //编写类 A01 定义方法 max 实现求某个 double数组的最大值，并返回
  //思路分析
        1.类名 A01
        2.方法名 max
        3.形参 （double[]）
        4.返回值 double
        
	//先完成正常业务，然后考虑代码健壮性。
public A01{
	public Double max(double[] arr){
    if(arr!=null && arr.length > 0){ //非空判断必须在前！
      double max = arr[0];
      for(int i = 1 ; i < arr.length; ++i){
        if(max < arr[i]){
          max=arr[i];
        }
      }
      return max; //double
    }else{
      return null;  // 这里用了 double 的包装类 Double，可以返回 null 。普通的 double 类型是没有 null 值的。因为不是引用类型。
    }
  }
｝
```

以上代码 double -> Double 涉及到自动装箱和自动拆箱的过程，之后再说。

圆周率 π 可以用 Math.PI 表示

*<u>**java中 2.3/0 浮点型除以 0会得到 Infinity。整形 n / 0  会报错 ！**</u>* 异常错误 java.lang.ArithmeticException：/ by zero

`new Test().count1();`  是一个匿名对象！因为没有赋值给任何一个对象变量。只能用一次。使用后就被销毁了！

