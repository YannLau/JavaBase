P374——P424

[toc]

# 类变量和类方法 static

> 什么是类变量？
>
> 类变量也叫静态变量/静态属性，是该类的所有对象共享的变量，任何一个该类的对象去访问它时，取到的都是相同的值，同样任何一个该类的对象去修改它时，修改的也是同一个变量。这个从前面的图也可看出来。

> 定义语法：
>
> 访问修饰符 static 数据类型 变量名；［推荐］
> static 访问修饰符 数据类型 变量名；

> 类变量在内存的哪里？
>
> JDK8 以前静态变量（类变量）存在于方法区加载类时产生的静态域中。JDK8 以后加载类时，会在堆区生成一个 Class对象（Class实例），类变量就存放在Class 实例的尾部。
>
> 不管static 变量在哪里，共识（1） static 变量是同一个类所有对象共享（2） static类变量，在类加载的时候就生成了.

> 如何访问类变量？
>
> 类名.类变量名
> 或者 对象名.类变量名【静态变量的访问修饰符的访问权限和范围 和 普通属性是一样的。】
> 推荐使用：类名.类变量名；

> 类变量使用细节
>
> 1. 什么时候需要用类变量
>   当我们需要让某个类的所有对象都共享一个变量时，就可以考虑使用类变量（静态变量）：比如：定义学生类，统计所有学生共交多少钱。Student （name, fee）
> 2. 类变量与实例变量（普通属性）区别
>   类变量是该类的所有对象共享的，而实例变量是每个对象独享的。
> 3. 加上static称为类变量或静态变量，否则称为实例变量/普通变量/非静态变量
> 4. 类变量可以通过 类名.类变量名 或者 对象名.类变量名 来访问，但java设计者推荐我们使用 类名.类变量名方式访问。【前提是 满足访问修饰符的访问权限和范围】
> 5. 实例变量不能通过 类名.类变量名 方式访问。
> 6. 类变量是在类加载时就初始化了，也就是说，即使你没有创建对象，只要类加载了，就可以使用类变量了。
> 7. 类变量的生命周期是随类的加载开始，随着类消亡而销毁。

> 类方法
>
> 也叫静态方法。
>
> 书写方法：
>
> 访问修饰符 static 数据返回类型 方法名()｛｝【推荐】
> static 访问修饰符 数据返回类型 方法名()｛｝
>
> 类方法调用：
>
> 使用方式：类名.类方法名 或者 对象名.类方法名【前提是 满足访问修饰符的访问权限和范围】

> 类方法经典的使用场景
> >当方法中不涉及到任何和对象相关的成员，则可以将方法设计成静态方法，提高开发效率。
> >比如：工具类中的方法 Util 类、Math 类、Arrays类、Collections 集合类
> >
> >> 小结
> >>
> >> 在程序员实际开发，往往会将一些通用的方法，设计成静态方法，这样我们不需要创建对象就可以使用了，比如打印一维数组，冒泡排序，完成某个计算任务 等

> 类方法使用细节
>
> 1）类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区：类方法中无this的参数，普通方法中隐含着this的参数。
> 2） 类方法可以通过类名调用，也可以通过对象名调用。
> 3） 普通方法和对象有关，需要通过对象名调用，比如对象名.方法名（参数），不能通过类名调用。
> 4） 类方法中不允许使用和对象有关的关键字，比如this和super。普通方法（成员方法）可以。
> 5） 类方法（静态方法）中 只能访问 静态变量 或静态方法。
> 6） 普通成员方法，既可以访问 普通变量（方法），也可以访问静态变量（方法）。
>
> 小结：静态方法，只能访问静态的成员，非静态的方法，可以访问静态成员和非静态成员（必须遵守访问权限）。

> yannlau补充:
>
> java 类的静态方法可以被重写吗？
>
> ChatGPT
>
> 在Java中，静态方法是属于类的而不是对象的，因此它们不支持被重写。静态方法是与类关联而不是与对象关联的，因此子类不能重写父类的静态方法。如果在子类中声明一个与父类静态方法签名相同的静态方法，它只是隐藏了父类的静态方法，而不是重写它。
>
> 当在子类中声明一个与父类静态方法相同的静态方法时，会发生"方法隐藏"而不是"方法重写"。在这种情况下，方法调用将取决于引用类型，而不是实际对象类型。如果通过父类引用调用该方法，将调用父类的静态方法；如果通过子类引用调用该方法，将调用子类的静态方法。
>
> 总的来说，<u>***静态方法不会遵循动态分派的规则，因此无法被重写。***</u>

> 那么 java 的静态类不支持动态绑定机制吗？父类中调用一个静态方法不会现在子类中查找吗？
>
> ChatGPT
>
> 在Java中，静态方法和静态成员是与类相关联而不是与对象相关联的，因此它们不参与动态绑定（也称为运行时多态性）。动态绑定是通过对象的类型来解析方法调用的，而不是通过引用的类型。由于静态成员和方法与类相关，而不是与对象相关，所以它们不受动态绑定的影响。
>
> 当通过一个类的引用调用静态方法时，会直接使用该类中定义的静态方法，而不会根据实际对象的类型进行查找。因此，即使通过父类的引用调用静态方法，也会调用父类中定义的静态方法，而不是在子类中查找。
>
> 示例：
>
> ```java
> class Parent {
>     static void staticMethod() {
>         System.out.println("Parent's static method");
>     }
> }
> 
> class Child extends Parent {
>     static void staticMethod() {
>         System.out.println("Child's static method");
>     }
> }
> 
> public class Main {
>     public static void main(String[] args) {
>         Parent.staticMethod(); // 调用父类的静态方法
>         Child.staticMethod();  // 调用子类的静态方法
> 
>         Parent parentReference = new Child();
>         parentReference.staticMethod();  // 仍然调用父类的静态方法
>     }
> }
> ```
>
> 在上述示例中，无论是通过父类引用还是子类引用调用静态方法，实际上都是直接使用引用类型所属类中定义的静态方法，而不会动态查找。



# 深入理解 main 方法

> 解释main方法的形式：`public static void main（String［］ args){}`
>
> 1. java虚拟机需要调用类的main方法，所以该方法的访问权限必须是public）
>
> 2. java虚拟机在执行main()方法时不必创建对象，所以该方法必须是static
> 3. 该方法接收String类型的数组参数，该数组中保存执行java命令时传递给所运行的类的参数，案例演示，接收参数.
> 4. java 执行的程序 参数1 参数2 参数3

> 理解 main 方法语法
>
> 1） 在main方法中，我们可以真接调用main方法所在类的静态方法或静态属性。
> 2） 但是，不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员。

> 在 IDEA 中动态传参
>
> Run/Bug Configuration ——> Program arguments

# 代码块/初始化块

代码化块又称为初始化块，属于类中的成员［即 是类的一部分］，类似于方法，将逻辑语句封装在方法体中，通过f包围起来。

但和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或类显式调用，而是加载类时，或创建对象时隐式调用。

> 基本语法
>
> `［修饰符］｛`
> 	`代码`
> `｝;`
>
> 注意：
> 1） 修饰符 可选，要写的话，也只能写 static
> 2）代码块分为两类，使用static 修饰的叫静态代码块，没有static修饰的，叫普通代码块。
> 3）逻辑语句可以为任何逻辑语句（输入、输出、方法调用、循环、判断等）
> 4）; 分号可以写上，也可以省略。

> 代码块的好处和理解：
> 1）相当于另外一种形式的构造器（对构造器的补充机制），可以做初始化的操作
> 2） 如果多个构造器中都有重复的语句，可以抽取到初始化块中，提高代码的重用性

> 使用场景
>
> （1） 三个构造器都有相同的语句
> （2） 这样代码看起来比较冗余
> （3）这时我们可以把相同的语句，放入到一个代码块中
> （4）这样当我们不管调用哪个构造器，创建对象，都会先谓用代码块的内容
> （5）代码块调用的顺序优先于构造器。

> 代码块使用注意事项和细节
>
> 1. static代码块也叫静态代码块，作用就是对类进行初始化，而且它随着类的加载而执行，并且只会执行一次。如果是普通代码块，每创建一个对象，就执行。
> 2. 类什么时候被加载【重要】
>    1. 创建对象实例时（new）
>    2.  创建子类对象实例，父类也会被加载 (而且要先加载父类) 注意类加载和对象实例化是不一样的。~~经过代码验证发现，一个类的加载过程是，先加载字类的成员（包括静态成员和非静态成员并进行初始化），然后执行静态代码块~~，因为静态代码块可以访问到静态成员！
>    3.  使用类的静态成员时（静态属性，静态方法）
>       案例演示：A类 extends B类 的静态块
> 3. 普通的代码块，在创建对象实例时，会被隐式的调用。
>    被创建一次，就会调用一次。如果只是使用类的静态成员时，普通代码块并不会执行。
> 4. 创建一个对象时，在一个类 调用顺序是：（重点，难点）：
>    1.  调用静态代码块和静态属性初始化（注意：静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态变量初始化，则按他们定义的顺序调用）
>    2.  调用普通代码块和普通属性的初始化（注意：普通代码块和普通属性初始化调用的优先级一样，如果有多个普通代码块和多个普通属性初始化，则按定义顺序调用）
>    3. 调用构造方法。
>    4. 类的方法（静态方法）加载的更早，比静态代码块和静态属性更早。
> 5. 构造方法（构造器）的最前面其实隐含了 super() 和 调用普通代码块，静态相关的代码块，属性初始化，在类加载时，就执行完毕，因此是优先于 构造器和普通代码块执行的
> 6. 我们看一下创建一个子类对象时（继承关系），他们的静态代码块，静态属性初始化，普通代码块，普通属性初始化，构造方法的调用顺序如下：
>    1.  父类的静态代码块和静态属性（优先级一样，按定义顺序执行）
>    2.  子类的静态代码块和静态属性（优先级一样，按定义顺序执行）
>    3. 父类的普通代码块和普通属性初始化（优先级一样，按定义顺序执行）
>    4. 父类的构造方法
>    5. 子类的普通代码块和普通属性初始化（优先级一样，按定义顺序执行）
>    6. 子类的构造方法
> 7. 静态代码块只能直接调用静态成员（静态属性和静态方法），普通代码块可以调用任意成员。
> 8. YannLau补充：类的静态部分只有在第一次类被加载时才会执行或初始化。第二次创建相关对象时就不用在加载了！包括继承关系的子类第一次加载时也不会再加载了。因为已经加载过了。

# 单例设计模式

> 什么是设计模式？
>
> 1. 静态方法和属性的经典使用
> 2. 设计模式是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式。设计模式就像是经典的棋谱，不同的棋局，我们用不同的棋谱，免去我们自己再思考和摸索。

> 什么是单例模式？
>
> 单例（单个的实例）
> 1. 所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法
> 2. 单例模式有两种方式：1）饿汉式 2）懒汉式

> 饿汉式（可能还没有用到，对象就已经创建好了）
>
> 1） 构造器私有化
> 2） 类的内部创建对象（该对象是 static 的）直接 new 出来一个对象。
> 3） 向外暴露一个静态的公共方法 getlnstance，返回 对象。
> 4） 代码实现

> 懒汉式
>
> 引用变量 默认值是 null ，因此创建对象的引用，不直接 new 而是在 getInstance 中 new，并添加判断，使得确保唯一性。
>
> 1. 仍然構造器私有化
> 2. 定義一個static靜態屬性對象 不赋值或者置为 null
> 3. 提供一個public的static方法，可以返回一個Cat對象
> 4. 懶漢式，只有當用戶使用getInstance時，才返回cat對象，後面再次調用時，會返回上次創建的cat對象從而保證了單例

> 饿汉式和懒汉式比较
>
> 饿汉式VS懒汉式
>
> 1. 二者最主要的区别在于创建对象的时机不同：饿汉式是在类加载就创建了对象实例，而懒汉式是在使用时才创建。
> 2. 饿汉式不存在线程安全问题，懒汉式存在线程安全问题。（后面学习线程后，会完善一把）
> 3. 饿汉式存在浪费资源的可能。因为如果程序员一个对象实例都没有使用，那么饿汉式创建的对象就浪费了，懒汉式是使用时才创建，就不存在这个问题。
> 4. 在我们javaSE标准类中，java.lang.Runtime就是经典的单例模式。

# final 关键字

> final 中文意思：最后的，最终的.
> final 可以修饰类、属性、方法和局部变量。
>
> 在某些情况下，程序员可能有以下需求，就会使用到final
>
> 1）当不希望类被继承时，可以用final修饰.
>
> 2）当不希望父类的某个方法被子类覆盖/重写（override）时，可以用final关键字修饰。【案例演示：访问修饰符 final 返回类型 方法名】
>
> 3）当不希望类的的某个属性的值被修改，可以用final修饰.【案例演示：public final double TAX_RATE=0.08]
>
> 4）当不希望某个局部变量被修改，可以使用final修饰【案例演示：final double TAX RATE =0.08 ]

> final  关键子使用细节
>
> 1. final修饰的属性又叫常量，一般 用 XX_XX_XX_XX 来命名
> 2. final修饰的属性在定义时，必须赋初值，并且以后不能再修改，赋值可以在如下位置之一【选择一个位置赋初值即可】：
>    1. 定义时：如 public final double TAX RATE=0.08；
>    2. 在构造器中。
>    3. 在代码块中。
> 3. 如果final修饰的属性是静态的，则初始化的位置只能是
>    1. 定义时
>    2. 在静态代码块，不能在构造器中赋值。final类不能继承，但是可以实例化对象。
> 4. final类不能继承，但是可以实例化对象。
> 5. 如果类不是final类，但是含有final方法，则该方法虽然不能重写，但是可以被继承。
> 6. 一般来说，如果一个类已经是final类了，就没有必要再将方法修饰成final方法。
> 7. final不能修饰构造方法（即构造器）
> 8. final 和 static 往往搭配使用，效率更高，底层编译器做了优化处理。
> 9. 包装类（Integer, Double,Float, Boolean等都是final），String也是final类。

# 抽象类abstract

父类方法的不确定性 ==> 考虑将该方法设计为抽象(abstract)方法。所谓抽象的方法就是指没有实现没有方法体的方法！当一个类中存在抽象方法时，需要将类声明为抽象类！给类定义增加 abstract 关键字。并让子类实现该方法（且必须要实现，除非子类也设为 abstract）

> 语法: 
>
> ```java
> public abstract class Animal{
> 
> 	public abstract void eat(); //不写方法体
> 	public void getWeight(){
> 		...
> 	}
> }
> ```

小结：
当父类的某些方法，需要声明，但是又不确定如何实现时，可以将其声明为抽象方法，那么这个类就是抽象类。

> 介绍
>
> 1） 用abstract 关键字来修饰一个类时，这个类就叫抽象类
> 访问修饰符 abstract类名｛ ｝
> 2） 用abstract关键字来修饰一个方法时，这个方法就是抽象方法 —— 访问修饰符 abstract 返回类型 方法名（参数列表）：//没有方法体
> 3） 抽象类的价值更多作用是在于设计，是设计者设计好后，让子类继承并实现抽象类()
> 4）抽象类，是考官比较爱问的知识点，在框架和设计模式使用较多。

> 抽象类细节
>
> 1. 抽象类不能被实例化
>
> 2. 抽象类不一定要包含abstract方法。也就是说，抽象类可以没有abstract方法
>
> 3. 一旦类包含了abstract方法，则这个类必须声明为abstract 
>
> 4. abstract 只能修饰类和方法，不能修饰属性和其它的 
>
> 5. 抽象类可以有任意成员【抽象类还是类】，比如：非抽象方法、构造器、静态属性等等
>
> 6. 抽象方法不能有主体，即不能实现implement
>
> 7. 如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为abstract类。那如果抽象父类只是声明为抽象类但不包含任何抽象方法的话，也就不用实现了。
> 8. 抽象方法不能使用private、final 和 static来修饰，因为这些关键字都是和重写相违背的。

> 为什么抽象方法不能用 private 关键字修饰？
>
> ChatGPT
> 在Java中，抽象方法是声明在抽象类或接口中的方法，而抽象方法的目的是为了让派生类（子类）提供具体的实现。抽象方法是一种约定，它告诉子类必须提供对应的实现。
>
> 使用`private`关键字修饰抽象方法是不合法的，原因如下：
>
> 1. **访问权限问题：** `private`修饰的成员只能在声明它的类内部访问，对外不可见。而抽象方法的目的是为了被子类实现，如果将抽象方法声明为`private`，那么子类将无法访问该方法，从而无法提供实现。
> 2. **继承和多态性：** 抽象方法是为了促使子类提供具体实现，而`private`方法不能被继承，因此无法达到这个目的。子类无法继承私有方法，因此无法提供相应的实现。
>
> 如果将抽象方法声明为`private`，就违背了其设计目的，因为它无法被子类继承和实现，从而失去了多态性和继承的优势。因此，Java中规定抽象方法不能使用`private`修饰符。

> 有 静态抽象方法 一说吗？
>
> 在Java中，抽象方法是一种声明在抽象类或接口中的方法，而静态方法是与类相关联而不是与对象相关联的。在Java 8及之前的版本中，抽象方法不能是静态的。然而，从Java 8开始，接口中可以包含静态方法。
>
> 具体来说，Java 8引入了接口的默认方法和静态方法。接口中的静态方法可以提供一些通用的功能，而不需要实现类去实现这些方法。这使得在接口中引入新方法时更加灵活，而不会破坏已有的实现类。
>
> 示例：
>
> ```java
> interface MyInterface {
>     void abstractMethod(); // 抽象方法
> 
>     static void staticMethod() {
>         System.out.println("Static method in interface");
>     }
> }
> 
> class MyClass implements MyInterface {
>     @Override
>     public void abstractMethod() {
>         System.out.println("Implementation of abstract method");
>     }
> }
> 
> public class Main {
>     public static void main(String[] args) {
>         MyInterface.staticMethod(); // 调用接口中的静态方法
> 
>         MyClass myClass = new MyClass();
>         myClass.abstractMethod();    // 调用实现类中的抽象方法
>     }
> }
> ```
>
> 在上述示例中，`MyInterface`接口包含一个抽象方法`abstractMethod`和一个静态方法`staticMethod`。实现类`MyClass`需要提供对抽象方法的具体实现，但不需要实现静态方法。静态方法可以直接通过接口名调用，而不需要创建接口的实例。

# 抽象类的实践——模板设计模式

> 需求
>
> 1）有多个类，完成不同的任务job
> 2） 要求能够得到各自完成任务的时间
> 3） 请编程实现
>
> 1. 先用最容易想到的方法
>
> 2. 分析问题，提出使用模板设计模式

`long end = System.currentTimeMills();`得到当前的时间戳！

设计一个抽象类（Template），能完成如下功能：
1） 编写方法calculateTimeO，可以计算某段代码的耗时时间
2） 编写抽象方法job0
3）编写一个子类Sub，继承抽象类Template，并实现job方法。
4） 编写一个测试类TestTemplate，看看是否好用。

```java
abstract class Template{//抽象类
  
		public abstract void job();//抽象方法
  
		public void caleTimes(){// 统计耗时多久是确定
			//统计当前时间距离 1970-1-1 0:0:0的时间差，单位ms
			long start = System.currentTimeMillis;
			job();  //动态绑定机制
			long end = System.currentTimeMillis;
			System.out.printin("耗时: "+(end-start));
		}
}
```

会涉及多态的动态绑定机制！

# 接口 interface

> 接口就是给出一些没有实现的方法，封装到一起，到某个类要使用的时候，在根据具体情况把这些方法写出来。语法：
>
> `interface 接口名{`
>
> ​	`//属性`
>
> ​	`//方法`
>
> `}`
>
> `class 类名 implements 接口1,接口2,接口3{`
>
> ​	`//自己属性`
>
> ​	`//自己方法`
>
> ​	`//必须实现的接口抽象方法`
>
> `}`
>
> 小结：
>
> 1. 在Jdk7.0前 接口里的所有方法都没有方法体。即都是抽象的方法（一般不写 abstract 关键字）。在接口中，抽象方法，可以省略 abstract 关键字。
> 2. Jdk8.0后接口类可以有静态方法，默认方法（default 修饰——default 放在访问修饰符前面），也就是说接口中可以有方法的具体实现。

> 接口的深入讨论
>
> 对初学者讲.理解接口的概念不算太难，难的是不知道什么时候使用接口，下面我例举几个应用场景：
> 1. 说现在要制造战斗机，武装真升机.专家只需把飞机需要的功能/规格定下来即可，然后让别的人具体实现就可。
>
> 2. 说现在有一个项目经理.管理三个程序员，功能开发一个软件，为了控制和管理软件，项目经理可以定义一些接口，然后由程序员具体实现。
>
>   实际要求：3个程序员，编写三个类，分别完成对Mysql,Oracle,DB2数据库的连接。

> 接口的注意事项和细节
>
> 1）接口不能被实例化
> 2）接口中所有的方法是 public方法，不写访问修饰符也是默认为 public，接口中抽象方法，可以不用abstract 修饰 `public void aaa();  等价于    public abstract void aaa();`不用加花括号！
> 3） 一个普通类实现接口，就必须将该接口的所有方法都实现。
> 4） 抽象类实现接口，可以不用实现接口的方法。
> 5） 一个类同时可以实现多个接口
> 6）接口中的属性，只能是final的，而且是 public static final 修饰符。比如：int a=1；实际上是 `public static final` int a=1;（必须初始化）
> 7） 接口中属性的访问形式：`接口名.属性名`
> 8） 一个接口不能继承其它的类，但是可以继承多个别的接口 `interface A extends B,C {}`
> 9)接口的修饰符 只能是 public 和 默认，这点和类的修饰符是一样的。

# 接口 VS 继承类

小结：当子类继承了父类，就自动的拥有父类的功能
如果子类需要扩展功能，可以通过实现接口的方式了扩展。

可以理解 实现接口 是 对 java 单继承机制的一种补充。

> 接口和继承解决的问题不同
>
> 1. 继承的价值主要在于：解决代码的复甩性和可维护性。
>
> 2. 接口的价值主要在于：设计，设计好各种规范（方法），让其它类去实现这些方法。
>
> 接口比继承更加灵活
>
> 1. 接口比继承更加灵活，继承是满足 is-a的关系，而接口只需满足like-a的关系。
>
> 接口在一定程度上实现代码解耦【即 接口规范性 + 动态绑定】

# 接口的多态性

1） 多态参数（前面案例体现）InterfacePolyParameter.java
在前面的Usb接口案例，`Usblnterface usb`，既可以接收手机对象，又可以接收相机对象，就体现了 接口 多态（接口引用可以指向实现了接口的类的对象）。

> 接口类型的变量 可以指向 实现了该接口的类的对象

2） 多态数组 InterfacePolyArr.java
演示一个案例：给Usb数组中，存放 Phone 和 相机对象， Phone类还有一个特有的方法call()。请遍历Usb数组，如果是Phone对象，除了调用Usb 接口定义的方法外，还需要调用 Phone 特有方法 call。

3）接口存在多态传递现象.InterfacePolyPass.java

> 1. 接口类型的变量可以指向，实现了该接口的类的对象实例
> 2. 如果A接口继承了另一个B 接口。而类 C 实现了 A 接口，就相当于类 C也实现了 B 接口，那么，B 接口引用变量可以用来指向 类C 的实例对象。这就是接口的多态传递现象！

当一个对象访问一个父类和实现的接口都有的变量时，用 super.变量名指定父类变量，用 接口名.变量名指代接口变量，避免混淆，否则编译器会报错！

# 内部类

Java 程序员水平的分水岭！

一个类的内部又完整的嵌套了另一个类结构。被嵌套的类称为内部类（inner class），嵌套其他类的类称为外部类（outer class）。是我们类的第五大成员

内部类最大的特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系。

内部类是学习的难点，同时也是重点，后面看底层源码时会遇到大量的内部类！

> 基本语法
>
> ```java
> class Outer{ //外部类
>   class Inner{  //内部类
>     
>   }
> }
> class Other{  //外部其他类
>   
> }
> ```

> 分类
>
> 1. 定义在外部类局部位置上 （比如方法内）：
>    1. 局部内部类（有类名）
>    2. 匿名内部类（没有类名，重点!!!!!!!!!!!!!!!）
> 2. 定义在外部类的成员位置上：
>    1. 成员内部类（没用static修饰）
>    2. 静态内部类（使用static修饰）

# 内部类——局部内部类

> 说明：局部内部类是定义在外部类的局部位置，比如通常在方法中，并且有类名。
>
> 1. 可以直接访问外部类的所有成员，包含私有的
> 2. 不能添加访问修饰符，因为它的地位就是一个局部变量。局部变量是不能使用修饰符的。但是可以使用final修饰，因为局部变量也可以使用 final
> 3. 作用域：仅仅在定义它的方法或代码块中。
> 4. 局部内部类——访问——>外部类的成员
>    【访问方式：直接访问】
> 5. 外部类——访问——>局部内部类的成员。访问方式：创建对象，再访问（<u>***注意：必须在作用域内。***</u>）
> 6. 外部其他类—--不能访问—->局部内部类（因为 局部内部类地位是一个局部变量）
> 7. 如果外部类和局部内部类的成员重名时，默认遵循就近原则，内部类的实例对象如果想访问外部类的成员，则可以使用（`外部类名.this.成员`）去访问。
> 8. （`外部类名.this`）**<u>*本质就是指代外部类的调用本方法以至于创建了内部类的外部对象实例.*</u>**
> 9. 内部类中直接使用 this 代表的内部类自己的对象本身。

> 记住：
>
> （1）局部内部类定义在方法中/代码块
> （2） 作用域在方法体或者代码块中
> （3） 本质仍然是一个类



# 内部类——匿名内部类

> 本质是一个类 ! 是内部类 ! 该类没有名字 ! `同时还是一个对象!`
>
> 说明：
>
> 匿名内部类是定义在外部类的局部位置，比如方法中，并且没有类名。

> 1. 匿名内部类的基本语法
>
>    ```java
>    类/接口名 变量名 = new 类或接口(参数列表){
>    		类体
>    }; //会生成一个匿名内部类并且继承了等号左边类或者实现了等号左边的接口.
>    //当是继承一个类的匿名内部类时会使用到参数列表,直接传递给被继承的类的对象构造器.
>    ```
>
> 2. 底层其实发生了创建类的过程
> 2. 匿名内部类会被系统分配一个名字  `外部类名 $ 1/2/3`
> 2. JDK底层在创建了匿名内部类后,立即马上就创建了其对应的实例对象,并且把地址返回给  `对象引用 或者 作为实参传入调用函数.`
> 2. 匿名内部类使用一次就不能再使用了,但接收其返回对象的引用还可以一直用.

 

> 匿名内部类的使用
>
> 1. 语法见上
>
> 2. 匿名内部类的语法比较奇特，请大家注意，因为匿名内部类既是一个类的定义,同时它本身也是一个对象，因此从语法上看，它既有定义类的特征，也有创建对象的特证，对前面代码分析可以看出这个特点，因此可以调用匿名内部类方法.
> 3. 可以直接访问外部类的所有成员，包含私有的
> 4. 不能添加访问修饰符，因为它的地位就是一个局部变量。
> 5. 作用域：仅仅在定义它的方法或代码块中.
> 6. 匿名内部类---访问---->外部类成员［访问方式：直接访问］
> 7. 外部其他类—--不能访问----->匿名内部类（因为 匿名内部类地位是一个局部变量）
> 8. 如果外部类和内部类的成员重名时，内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，则可以使用（`外部类名.this.成员`）去访问
> 9. 对匿名内部类对象的方法调用仍然有动态绑定机制的存在!











> YannLau 补充
>
> java 创建匿名内部类一定要去继承一个父类或者实现一个接口吗？
>
> ChatGPT
>
> 在Java中，匿名内部类通常是通过继承一个父类或者实现一个接口来创建的，但并不是一定要这样做。匿名内部类的创建方式可以根据需要选择，可以是继承一个类，也可以是实现一个接口。
>
> 如果你希望创建一个匿名内部类并实现某个接口的方法，可以这样做：
>
> ```java
> javaCopy code
> MyInterface myObject = new MyInterface() {
>     @Override
>     public void myMethod() {
>         // 实现接口方法的具体逻辑
>     }
> };
> ```
>
> 或者，如果你希望创建一个匿名内部类并继承自某个类，可以这样做：
>
> ```java
> javaCopy code
> MyClass myObject = new MyClass() {
>     @Override
>     public void myMethod() {
>         // 继承类的方法并提供具体实现
>     }
> };
> ```
>
> 但是，如果你只是想创建一个对象而不需要扩展某个类或实现某个接口，也是可以的。例如：
>
> ```java
> javaCopy code
> Object myObject = new Object() {
>     // 匿名内部类的代码块
> };
> ```
>
> 在这种情况下，匿名内部类就是一个匿名的子类，它继承自`Object`类，但没有增加额外的方法或属性。
>
> 总体而言，匿名内部类的创建方式取决于你的需求，它可以继承类、实现接口，也可以仅作为一个对象使用。





# 内部类——成员内部类

说明：成员内部类是定义在外部类的成员位置，并且没有static修饰。
1. 可以直接访问外部类的所有成员，包含私有的

2. 可以添加任意访问修饰符（public、protected、默认。Private），因为它的地位就是一个成员。
3. 作用域  :  和外部类的其他成员一样，为整个类体 .
4. 成员内部类—--访问—-->外部类（比如：属性）
  ［访问方式：直接访问］（说明）
5. 外部类—-访问—---->内部类（说明）
  访问方式：创建对象，再访问
6. 外部其他类—>访问-->成员内部类

```java
public class Testinner3 {
	public static void main(String[] args) {
		//其它外部类访问内部类，方式1
		Outer01 outer01 = new Outer01();
		Inter01 inter01 = outer01.new Inter01();
		//方式2：
		Inter01 inter012 = new Outer01().new Innter01();
		//方式3：使用一个方法来获取，更加简洁
		Inter01 inter01Instance = new Outer01().getInnter01Instance();
  }
}
class Outer01{
  
	private int n1 = 10;
  
	public String name = "张三”；
    
	class Innter01{
		public void say(){
				System. out.println("Outer01 的 n1 = " + n1 +
" outer01 的 name = "+ name );
    }
		public Inter01 getinnter01Instance(){
			return new Inter01();
    }
		private void show(){
			Inter01 inter01 = new Inter01():
			inter01.say():
    }
  }
}
```

7. 如果外部类和内部类的成员重名时，内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.this.成员）去访问



# 内部类——静态内部类

说明：静态内部类是定义在外部类的成员位置，并且有static修饰
1. 可以直接访问外部类的所有静态成员，包含私有的，`但不能直接访问非静态成员`
2. 可以添加任意访问修饰符（public. protected、默认 和private），因为它的地位就是一个成员。
3. 作用域：同其他的成员，为整个类体
4. 静态内部类---访问---->外部类（比如：静态属性）［访问方式：直接访问所有静态成员]
5. 外部类---访问-—--＞静态内部类 访问方式：创建对象，再访问
6. 外部其他类—访问—----＞静态内部类

```java
//方式1
//因为静态内部类，是可以通过类名直接访问（前提是满足访问权限〕
Outer10.Inner10 inner10 = new Outer10.Inner10();
inner10. say();

//方式2
//编写一个方法，可以返回静态内部类的对象实例。
Outer10.Inner10 inner101 = outer10.getInner10();
inner101. say();

```

7. 如果外部类和静态内部类的成员重名时，静态内部类访问的时，默认遵循就近原则，如果想访问外部类的成员，则可以使用`（外部类名.成员）`去访问.
